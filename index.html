<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Drag Race Season Simulator</title>
  <link rel="stylesheet" href="style.css" />

  <!-- Card / collapsible styling -->
  <style>
    body {
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      background: #111;
      color: #eee;
      margin: 0;
    }

    .app {
      max-width: 960px;
      margin: 0 auto;
      padding: 1.5rem;
    }

    h1, h2, h3 {
      text-align: center;
      font-weight: 700;
      letter-spacing: 0.03em;
    }

    h1 {
      margin-bottom: 0.5rem;
    }

    h2 {
      margin-top: 1.5rem;
      margin-bottom: 0.75rem;
    }

    a {
      color: #ff80ab;
    }

    button {
      font-family: inherit;
    }

    /* ---- Layout / containers ---- */

    .hidden {
      display: none !important;
    }
    
    .toolbar {
      display: flex;
      flex-wrap: wrap;
      gap: 1rem;
      align-items: center;
      justify-content: space-between;
      background: #1e1e1e;
      padding: 0.75rem 1rem;
      border-radius: 999px;
      box-shadow: 0 0 0 1px #333;
      margin-bottom: 1rem;
    }

    .toolbar-group {
      display: flex;
      align-items: center;
      gap: 0.75rem;
      flex-wrap: wrap;
    }

    .toolbar label {
      font-size: 0.85rem;
      color: #ccc;
      display: flex;
      align-items: center;
      gap: 0.4rem;
    }

    .toolbar select {
      background: #222;
      color: #eee;
      border-radius: 999px;
      border: 1px solid #444;
      padding: 0.2rem 0.7rem;
      font-size: 0.85rem;
    }

    .toolbar input[type="checkbox"] {
      transform: translateY(1px);
    }

    .primary-button {
      border-radius: 999px;
      border: none;
      padding: 0.5rem 1.4rem;
      font-weight: 600;
      font-size: 0.95rem;
      background: linear-gradient(135deg, #ff4081, #ff80ab);
      color: #fff;
      cursor: pointer;
      box-shadow: 0 0 0 1px #000, 0 0 10px rgba(255, 64, 129, 0.4);
      transition: transform 0.08s ease, box-shadow 0.08s ease, filter 0.08s ease;
    }

    .primary-button:hover {
      transform: translateY(-1px);
      filter: brightness(1.05);
      box-shadow: 0 0 0 1px #000, 0 0 16px rgba(255, 64, 129, 0.65);
    }

    .primary-button:disabled {
      opacity: 0.6;
      cursor: default;
      transform: none;
      box-shadow: 0 0 0 1px #000;
    }

    .pill-toggle {
      display: inline-flex;
      align-items: center;
      gap: 0.5rem;
      padding: 0.25rem 0.75rem;
      border-radius: 999px;
      border: 1px solid #444;
      background: #181818;
      font-size: 0.8rem;
      cursor: pointer;
      user-select: none;
    }

    .pill-toggle input[type="checkbox"] {
      margin: 0;
    }

    /* ---- Episode cards ---- */

    .season-output {
      margin-top: 1.5rem;
      margin-bottom: 3rem;
    }

    .episode-card,
    details.episode-card {
      background: #181818;
      border-radius: 24px;
      padding: 1rem 1.25rem;
      margin-bottom: 0.75rem;
      border: 1px solid #333;
      box-shadow: 0 10px 35px rgba(0, 0, 0, 0.5);
    }

    .episode-card h3 {
      margin-top: 0.1rem;
      margin-bottom: 0.6rem;
      font-size: 1.1rem;
    }

    .episode-card pre {
      white-space: pre-wrap;
      font-family: "JetBrains Mono", ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      font-size: 0.85rem;
      background: #121212;
      padding: 0.75rem 0.9rem;
      border-radius: 14px;
      line-height: 1.5;
      border: 1px solid #333;
      max-height: 500px;
      overflow-y: auto;
    }

    .episode-card strong {
      color: #fff;
    }

    .episode-card .meta-line {
      font-size: 0.8rem;
      color: #bbb;
      margin-bottom: 0.5rem;
    }

    .episode-card .results-heading {
      font-size: 0.95rem;
      margin-bottom: 0.35rem;
      color: #ff80ab;
      font-weight: 600;
    }

    .episode-card .results-row {
      font-size: 0.9rem;
      margin-bottom: 0.15rem;
    }

    .episode-card .participant-row {
      margin-top: 0.4rem;
      font-size: 0.85rem;
    }

    .episode-card .episode-pill {
      display: inline-flex;
      align-items: center;
      gap: 0.4rem;
      border-radius: 999px;
      padding: 0.1rem 0.6rem;
      font-size: 0.72rem;
      text-transform: uppercase;
      letter-spacing: 0.08em;
      background: #242424;
      border: 1px solid #444;
      color: #ccc;
    }

    .episode-card .episode-pill span {
      opacity: 0.8;
    }

    .episode-card .step-meta {
      font-size: 0.8rem;
      color: #aaa;
      margin-bottom: 0.3rem;
      text-align: right;
    }

    .episode-card.step-cast {
      border-left: 4px solid #ff80ab;
    }

    .episode-card.step-episode_setup {
      border-left: 4px solid #90caf9;
    }

    .episode-card.step-episode_mini {
      border-left: 4px solid #ffb74d;
    }

    .episode-card.step-episode_results {
      border-left: 4px solid #66bb6a;
    }

    .episode-card.step-finale {
      border-left: 4px solid #e57373;
    }

    .episode-card.step-finale_runway,
    .episode-card.step-finale_top2_reveal,
    .episode-card.step-finale_lipsync,
    .episode-card.step-finale_winner {
      border-left: 4px solid #e57373;
    }

    .results-block {
      margin-top: 0.4rem;
    }

    .step-nav {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-top: 0.75rem;
      gap: 0.75rem;
    }

    .step-nav button {
      flex: 1;
      border-radius: 999px;
      border: none;
      padding: 0.45rem 0.8rem;
      font-size: 0.9rem;
      font-weight: 600;
      cursor: pointer;
      background: #262626;
      color: #eee;
      box-shadow: 0 0 0 1px #000;
      transition: background 0.08s ease, transform 0.08s ease, box-shadow 0.08s ease;
    }

    .step-nav button:hover:not(:disabled) {
      background: #333;
      transform: translateY(-1px);
      box-shadow: 0 0 0 1px #000, 0 0 10px rgba(0, 0, 0, 0.5);
    }

    .step-nav button:disabled {
      opacity: 0.55;
      cursor: default;
    }

    .step-nav button:last-child {
      background: linear-gradient(135deg, #ff4081, #ff80ab);
      color: #fff;
    }

    .step-nav button:last-child:hover:not(:disabled) {
      filter: brightness(1.05);
    }

    .step-exit {
  margin-top: 0.75rem;
}

    .step-exit button {
      width: 100%;
      border-radius: 999px;
      border: 1px solid #444;
      padding: 0.45rem 0.8rem;
      font-size: 0.9rem;
      font-weight: 600;
      cursor: pointer;
      background: #1f1f1f;
      color: #eee;
      box-shadow: 0 0 0 1px #000;
      transition: background 0.08s ease, transform 0.08s ease, box-shadow 0.08s ease;
    }
    
    .step-exit button:hover {
      background: #2a2a2a;
      transform: translateY(-1px);
      box-shadow: 0 0 0 1px #000, 0 0 10px rgba(0, 0, 0, 0.5);
    }

    /* Collapsible summary styling */

    details.episode-card {
      position: relative;
      border-left: 4px solid #4db6ac;
    }

    details.episode-card.summary-final {
      border-left-color: #e91e63;
    }

    .finale-card {
      border-left-color: #ffc107;
    }

    details.episode-card > summary {
      cursor: pointer;
      font-weight: 600;
      list-style: none;
    }

    details.episode-card > summary::-webkit-details-marker {
      display: none;
    }

    details.episode-card > summary::before {
      content: "▶";
      display: inline-block;
      margin-right: 0.4rem;
      font-size: 0.8rem;
    }

    details.episode-card[open] > summary::before {
      content: "▼";
    }

    .episode-card pre {
      white-space: pre-wrap;
      font-family: "JetBrains Mono", ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      font-size: 0.85rem;
      background: #121212;
      padding: 0.75rem 0.9rem;
      border-radius: 14px;
      line-height: 1.5;
      border: 1px solid #333;
      max-height: 500px;
      overflow-y: auto;
    }

    /* Track record styling */

    .track-record-toggle {
      margin-top: 0.5rem;
      text-align: right;
      font-size: 0.8rem;
      color: #ccc;
    }

    .track-record-toggle label {
      cursor: pointer;
      user-select: none;
    }

    .track-record-table-wrapper {
      margin-top: 0.75rem;
      overflow-x: auto;
      border-radius: 12px;
      border: 1px solid #333;
      background: #121212;
      padding: 0.25rem;
    }

    .track-record-table {
      width: 100%;
      border-collapse: collapse;
      margin-top: 0.75rem;
      font-size: 0.8rem;
    }

    .track-record-table th,
    .track-record-table td {
      border: 1px solid #333;
      padding: 0.25rem 0.35rem;
      text-align: center;
    }

    .track-record-table th {
      background: #222;
      font-weight: 600;
    }

    .track-record-table .track-name {
      text-align: left;
      white-space: nowrap;
      background: #202020;
      position: sticky;
      left: 0;
      z-index: 1;
    }

    .track-record-table .status-empty {
      background: #181818;
    }

    .track-record-table .status-win {
      background: #2e7d32;
      color: #c8e6c9;
      font-weight: 600;
    }

    .track-record-table .status-high {
      background: #1565c0;
      color: #bbdefb;
    }

    .track-record-table .status-safe {
      background: #424242;
    }

    .track-record-table .status-low {
      background: #f57c00;
      color: #ffe0b2;
    }

    .track-record-table .status-bottom {
      background: #c62828;
      color: #ffcdd2;
      font-weight: 600;
    }

    .track-record-table .status-elim {
      background: #804224;
      color: #ffe0d2;
      font-weight: 700;
    }

    .track-record-table .status-rtu {
      background: #CC8400;
      color: #fff3d5;
    }

    /* Finale-only cells (winner / runners-up) */
    .track-record-table .status-final-win {
      background: #d4af37;
      color: #111;
      font-weight: 700;
    }

    .track-record-table .status-final-runner1 {
      background: #b0bec5;
      color: #111;
      font-weight: 600;
    }

    .track-record-table .status-final-runner2 {
      background: #8d6e63;
      color: #fff3e0;
      font-weight: 600;
    }

    /* Cast builder / search styling */

    .builder-layout {
      display: grid;
      grid-template-columns: minmax(0, 1.7fr) minmax(0, 1.3fr);
      gap: 1.25rem;
    }

    @media (max-width: 880px) {
      .builder-layout {
        grid-template-columns: minmax(0, 1fr);
      }
    }

    .builder-panel {
      background: #181818;
      border-radius: 24px;
      padding: 1rem 1.25rem 1.25rem;
      border: 1px solid #333;
      box-shadow: 0 10px 35px rgba(0, 0, 0, 0.5);
    }

    .builder-panel h3 {
      margin-top: 0.1rem;
      margin-bottom: 0.75rem;
      text-align: left;
    }

    .subheading {
      font-size: 0.85rem;
      color: #bbb;
      margin-top: -0.3rem;
      margin-bottom: 0.75rem;
    }

    .search-input-row {
      display: flex;
      flex-wrap: wrap;
      gap: 0.6rem;
      align-items: center;
      margin-bottom: 0.4rem;
    }

    .search-input-row input[type="text"] {
      flex: 1;
      min-width: 220px;
      border-radius: 999px;
      border: 1px solid #444;
      background: #111;
      color: #eee;
      padding: 0.35rem 0.85rem;
      font-size: 0.9rem;
    }

    .search-input-row .small-label {
      font-size: 0.8rem;
      color: #bbb;
    }

    .search-input-row .pill-button {
      border-radius: 999px;
      border: 1px solid #444;
      background: #242424;
      color: #eee;
      padding: 0.3rem 0.85rem;
      font-size: 0.8rem;
      cursor: pointer;
      display: inline-flex;
      align-items: center;
      gap: 0.3rem;
      transition: background 0.08s ease, transform 0.08s ease, box-shadow 0.08s ease;
    }

    .search-input-row .pill-button:hover {
      background: #333;
      transform: translateY(-1px);
      box-shadow: 0 0 0 1px #000, 0 0 8px rgba(0, 0, 0, 0.5);
    }

    .search-input-row .pill-button.danger {
      border-color: #f44336;
      color: #ffcdd2;
    }

    .search-input-row .pill-button.danger:hover {
      background: #b71c1c;
      box-shadow: 0 0 0 1px #000, 0 0 8px rgba(244, 67, 54, 0.8);
    }

    .search-input-row .pill-button.secondary {
      border-color: #90caf9;
      color: #e3f2fd;
    }

    .search-input-row .pill-button.secondary:hover {
      background: #0d47a1;
      box-shadow: 0 0 0 1px #000, 0 0 8px rgba(144, 202, 249, 0.8);
    }

    .search-results {
      margin-top: 0.4rem;
      max-height: 260px;
      overflow-y: auto;
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
      gap: 0.55rem;
      padding-right: 0.25rem;
    }

    .search-result-card {
      background: #111;
      border-radius: 16px;
      padding: 0.5rem 0.6rem;
      border: 1px solid #333;
      font-size: 0.82rem;
      display: flex;
      flex-direction: column;
      gap: 0.4rem;
      cursor: pointer;
      transition: transform 0.1s ease, box-shadow 0.1s ease, background 0.1s ease;
    }

    .search-result-card:hover {
      transform: translateY(-1px);
      box-shadow: 0 0 0 2px #ff4081;
    }

    .search-result-card.added {
      /* kept same as normal to avoid weird green highlight */
    }

    .queen-row {
      display: flex;
      flex-wrap: wrap;
      justify-content: center;
      gap: 0.5rem;
      margin: 0.5rem 0 0.25rem;
    }

    .queen-avatar {
      text-align: center;
      font-size: 0.75rem;
      max-width: 90px;
    }

    .queen-avatar img {
      width: 72px;
      height: 72px;
      border-radius: 50%;
      object-fit: cover;
      border: 3px solid #ff4081;
      display: block;
      margin: 0 auto 0.25rem;
      background: #000;
    }
    .queen-row.neutral .queen-avatar img {
      border-color: rgba(200, 200, 200, 0.55) !important;
    }


    .queen-avatar-name {
      white-space: normal;
    }

    .queen-row-caption {
      text-align: center;
      margin-bottom: 0.75rem;
      font-size: 0.8rem;
    }

    /* Maxi-challenge full-view styling */

    .maxi-step {
      text-align: center;
      padding: 0.25rem 0 0.4rem;
    }

    .maxi-step .maxi-title {
      font-weight: 900;
      font-size: 1.8rem;
      margin: 0.35rem 0 0.75rem;
      letter-spacing: 0.02em;
    }

    .maxi-step .maxi-intro {
      font-size: 0.95rem;
      color: #ddd;
      margin: 0 0 0.9rem;
    }

    .maxi-step .perf-heading {
      font-size: 0.95rem;
      color: #ccc;
      margin: 0.6rem 0 0.2rem;
    }

    .queen-row.perf-row {
      margin-top: 0.35rem;
      margin-bottom: 0.25rem;
      gap: 0.6rem;
    }

    .queen-row.perf-row .queen-avatar img {
      width: 78px;
      height: 78px;
    }

    .queen-row.perf-row.perf-slayed .queen-avatar img { border-color: #8e24aa; }
    .queen-row.perf-row.perf-great  .queen-avatar img { border-color: #1565c0; }
    .queen-row.perf-row.perf-good   .queen-avatar img { border-color: #2e7d32; }
    .queen-row.perf-row.perf-bad    .queen-avatar img { border-color: #f57c00; }
    .queen-row.perf-row.perf-bombed .queen-avatar img { border-color: #c62828; }

    .queen-row.perf-row.perf-slayed .queen-avatar img { border-color: #8e24aa; }
    .queen-row.perf-row.perf-great  .queen-avatar img { border-color: #1565c0; }
    .queen-row.perf-row.perf-good   .queen-avatar img { border-color: #2e7d32; }
    .queen-row.perf-row.perf-bad    .queen-avatar img { border-color: #f57c00; }
    .queen-row.perf-row.perf-bombed .queen-avatar img { border-color: #c62828; }

    /* Placement rings (judging / bring-back reveals) */
    .queen-row.perf-row.perf-win    .queen-avatar img { border-color: #ff4081; }
    .queen-row.perf-row.perf-high   .queen-avatar img { border-color: #1565c0; }
    .queen-row.perf-row.perf-safe   .queen-avatar img { border-color: rgba(200, 200, 200, 0.55); }
    .queen-row.perf-row.perf-low    .queen-avatar img { border-color: #f57c00; }
    .queen-row.perf-row.perf-bottom .queen-avatar img { border-color: #c62828; }

    .judging-safe-line {
      margin: 0.45rem 0;
      font-size: 0.95rem;
      color: #eee;
    }
    .judging-divider {
      height: 1px;
      background: rgba(255,255,255,0.14);
      margin: 0.6rem 0;
    }

    .bbm-divider {
      height: 1px;
      background: rgba(255,255,255,0.16);
      margin: 0.9rem 0;
    }


    .maxi-step .perf-caption {
      font-size: 0.95rem;
      font-weight: 650;
      margin: 0.15rem 0 0.8rem;
      color: #eee;
    }

    /* Current cast list */
    .cast-list {
      margin-top: 0.6rem;
      display: flex;
      flex-wrap: wrap;
      gap: 0.6rem;
      min-height: 88px;
    }

    .cast-queen-card {
      display: inline-flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      min-width: 120px;
    }

    .cast-queen-card img {
      width: 80px;
      height: 80px;
      border-radius: 50%;
      object-fit: cover;
      border: 3px solid #ff4081;
      box-shadow: 0 0 0 2px #000;
      margin-bottom: 0.35rem;
      background: #000;
    }

    .cast-queen-name {
      font-size: 0.9rem;
      font-weight: 500;
      text-align: center;
    }

    .cast-queen-meta {
      font-size: 0.7rem;
      color: #bbb;
    }

    .cast-empty-hint {
      margin-top: 0.5rem;
      font-size: 0.8rem;
      color: #aaa;
      opacity: 0.9;
    }

    .cast-controls {
      margin-top: 0.5rem;
      font-size: 0.8rem;
      color: #ccc;
    }

    .cast-controls strong {
      color: #fff;
    }

    /* Custom queen editor */

    .custom-editor {
      margin-top: 0.5rem;
      padding-top: 0.6rem;
      border-top: 1px solid #333;
    }

    .custom-editor-row {
      display: flex;
      flex-wrap: wrap;
      gap: 0.6rem;
      margin-bottom: 0.4rem;
      align-items: flex-start;
    }

    .custom-editor-row label {
      font-size: 0.8rem;
      color: #ccc;
      display: flex;
      flex-direction: column;
      gap: 0.25rem;
      min-width: 130px;
      flex: 1;
    }

    .custom-editor-row input[type="text"],
    .custom-editor-row input[type="number"],
    .custom-editor-row input[type="url"],
    .custom-editor-row select {
      border-radius: 999px;
      border: 1px solid #444;
      background: #111;
      color: #eee;
      padding: 0.35rem 0.75rem;
      font-size: 0.85rem;
    }

    .custom-editor-row input[type="number"] {
      max-width: 70px;
    }

    .custom-editor-row input[type="url"] {
      min-width: 100px;
      font-size: 0.8rem;
    }

    .stat-grid {
      display: grid;
      grid-template-columns: repeat(2, minmax(0, 1fr));
      row-gap: 0.25rem;
      column-gap: 0.75rem;
      align-items: center;
      font-size: 0.8rem;
    }

    .stat-grid label span {
      display: inline-block;
      min-width: 70px;
    }

    .stat-grid input {
      max-width: 60px;
    }

    .stat-hint {
      font-size: 0.75rem;
      color: #aaa;
      margin-top: 0.15rem;
    }

    .editor-actions {
      margin-top: 0.5rem;
      display: flex;
      flex-wrap: wrap;
      gap: 0.5rem;
      align-items: center;
      justify-content: flex-start;
    }

    .editor-actions button {
      border-radius: 999px;
      border: 1px solid #444;
      background: #242424;
      color: #eee;
      padding: 0.35rem 0.9rem;
      font-size: 0.85rem;
      cursor: pointer;
      display: inline-flex;
      align-items: center;
      gap: 0.3rem;
      transition: background 0.08s ease, transform 0.08s ease, box-shadow 0.08s ease;
      flex: 1 1 140px;
      text-align: center;
      justify-content: center;
    }

    .editor-actions button:hover {
      background: #333;
      transform: translateY(-1px);
      box-shadow: 0 0 0 1px #000, 0 0 8px rgba(0, 0, 0, 0.5);
    }

    .editor-actions button.danger {
      border-color: #f44336;
      color: #ffcdd2;
    }

    .editor-actions button.danger:hover {
      background: #b71c1c;
      box-shadow: 0 0 0 1px #000, 0 0 8px rgba(244, 67, 54, 0.8);
    }

    .editor-actions button.secondary {
      border-color: #90caf9;
      color: #e3f2fd;
    }

    .editor-actions button.secondary:hover {
      background: #0d47a1;
      box-shadow: 0 0 0 1px #000, 0 0 8px rgba(144, 202, 249, 0.8);
    }

    .custom-queen-list {
      margin-top: 0.6rem;
      max-height: 220px;
      overflow-y: auto;
      border-radius: 12px;
      border: 1px solid #333;
      padding: 0.5rem;
      background: #111;
    }

    .custom-queen-row {
      display: grid;
      grid-template-columns: minmax(0, 1.7fr) auto;
      align-items: center;
      gap: 0.4rem 0.75rem;
      padding: 0.3rem 0.4rem;
      border-bottom: 1px solid #222;
      font-size: 0.83rem;
    }

    .custom-queen-row:last-child {
      border-bottom: none;
    }

    .custom-queen-main {
      display: flex;
      flex-wrap: wrap;
      gap: 0.3rem 0.6rem;
      align-items: center;
    }

    .custom-queen-name {
      font-weight: 600;
    }

    .custom-queen-stats {
      font-size: 0.75rem;
      color: #bbb;
    }

    .custom-queen-actions {
      display: flex;
      flex-wrap: wrap;
      gap: 0.25rem;
    }

    .custom-queen-actions button {
      border-radius: 999px;
      border: 1px solid #444;
      background: #242424;
      color: #eee;
      padding: 0.2rem 0.55rem;
      font-size: 0.75rem;
      cursor: pointer;
    }

    .custom-queen-actions button:hover {
      background: #333;
    }

    .edit-flags {
      display: flex;
      flex-wrap: wrap;
      gap: 0.3rem 0.75rem;
      margin-top: 0.25rem;
      font-size: 0.78rem;
    }

    .edit-flag-label {
      cursor: pointer;
      white-space: nowrap;
      display: inline-flex;
      align-items: center;
      gap: 0.25rem;
    }

    /* Results step polish */
    .results-step .perf-caption {
      font-weight: 800;
      font-size: 1.05rem;
      margin: 0.25rem 0 0.9rem;
      text-align: center;
    }


    .results-step .decision-line {
      color: #ff80ab;
      text-shadow: 0 0 10px rgba(255, 128, 171, 0.25);
      margin-bottom: 1.0rem;
    }

    .results-step .results-caption {
      font-weight: 850;
      font-size: 1.05rem;
      margin: 0.25rem 0 0.85rem;
    }

    .results-step .results-stay {
      color: #66bb6a;
      text-shadow: 0 0 10px rgba(102, 187, 106, 0.18);
    }

    .results-step .results-sashay {
      color: #e57373;
      text-shadow: 0 0 10px rgba(229, 115, 115, 0.18);
    }
  
/* Hide any accidental text under queen portraits (names were intentionally removed) */
.queen-avatar {
  font-size: 0;
  line-height: 0;
}
.queen-avatar img {
  display: block;
}

</style>
</head>
<body>
  <div class="app">
    <h1>Drag Race Season Simulator</h1>
    <p style="text-align:center; font-size:0.85rem; color:#ccc; max-width:42rem; margin:0.25rem auto 1.25rem;">
      Build a cast, tune the chaos, then simulate a full season in either a quick summary or step-by-step episode view.
    </p>

    <div class="toolbar" id="topToolbar">
      <div class="toolbar-group">
        <label>
          Mode:
          <select id="modeSelect">
            <option value="normal">Normal</option>
            <option value="chaos">Chaos</option>
          </select>
        </label>

        <label>
          View:
          <select id="viewSelect">
            <option value="summary">Summary</option>
            <option value="full">Full (step-by-step)</option>
          </select>
        </label>
      </div>

      <div class="toolbar-group">
        <label class="pill-toggle">
          <input type="checkbox" id="immunityToggle" checked />
          <span>Immunity (early episodes)</span>
        </label>

        <label class="pill-toggle">
          <input type="checkbox" id="doubleTwistsToggle" checked />
          <span>Double shantays/sashays</span>
        </label>

        <button id="simulateButton" class="primary-button">Simulate Season</button>
      </div>
    </div>

    <div class="builder-layout" id="builderScreen">
      <section class="builder-panel">
        <h3>Cast Builder &amp; Custom Queens</h3>
        <p class="subheading">
          Build a cast using the search. If you don't choose anyone, the default sample cast will be used.
        </p>

        <div class="search-input-row">
          <input
            id="queenSearchInput"
            type="text"
            placeholder="Start typing to search queens..."
          />
          <span class="small-label">Cast size: <span id="castSizeLabel">0</span></span>
          <input id="castSizeRange" type="range" min="6" max="16" step="1" value="12" />
          <span class="small-label">Current cast: <strong id="castCountLabel">0</strong></span>
        </div>

        <div class="search-input-row">
          <button id="randomCastBtn" class="pill-button secondary" type="button">
            Random
          </button>
          <button id="randomCustomCastBtn" class="pill-button secondary" type="button">
            Random customs
          </button>
          <button id="loadSampleBtn" class="pill-button secondary" type="button">
            Load sample cast
          </button>
          <button id="clearCastBtn" class="pill-button danger" type="button">
            Clear cast
          </button>
        </div>

        <div class="search-results" id="searchResults"></div>

        <div class="cast-controls">
          <div class="cast-empty-hint" id="castEmptyHint">
            No queens in the cast yet.
          </div>
          <div class="cast-list" id="castList"></div>
        </div>
      </section>

      <section class="builder-panel">
        <h3>Create or edit a custom queen</h3>
        <p class="subheading">
          Give your OC stats and story beats, then save her to use in any cast.
        </p>

        <div class="custom-editor">
          <div class="custom-editor-row">
            <label>
              Name:
              <input id="customName" type="text" placeholder="Queen name..." />
            </label>
            <label>
              Image URL:
              <input id="customImageUrl" type="url" placeholder="https://i.imgur.com/kXv2EFQ.png" />
            </label>
          </div>

          <div class="custom-editor-row">
            <div style="flex:1; min-width:220px;">
              <div class="stat-grid">
                <label>
                  <span>Acting:</span>
                  <input id="statActing" type="number" min="0" max="10" />
                </label>
                <label>
                  <span>Comedy:</span>
                  <input id="statComedy" type="number" min="0" max="10" />
                </label>
                <label>
                  <span>Dance:</span>
                  <input id="statDance" type="number" min="0" max="10" />
                </label>
                <label>
                  <span>Design:</span>
                  <input id="statDesign" type="number" min="0" max="10" />
                </label>
                <label>
                  <span>Improv:</span>
                  <input id="statImprov" type="number" min="0" max="10" />
                </label>
                <label>
                  <span>Runway:</span>
                  <input id="statRunway" type="number" min="0" max="10" />
                </label>
                <label>
                  <span>Lip Sync:</span>
                  <input id="statLipsync" type="number" min="0" max="10" />
                </label>
              </div>
              <div class="stat-hint">
                Stats should range from 0 to 10. Higher is better.
              </div>
            </div>

            <div style="flex:1; min-width:220px;">
              <label class="small-label" style="font-size:0.8rem; color:#ccc;">
                Traits &amp; edits:
              </label>
              <div class="edit-flags" style="margin-bottom:0.4rem;">
                <label class="edit-flag-label">
                  <input id="traitDramaProne" type="checkbox" />
                  <span>drama-prone</span>
                </label>
                <label class="edit-flag-label">
                  <input id="traitProducerFave" type="checkbox" />
                  <span>producer favorite</span>
                </label>
              </div>

              <div class="edit-flags" id="editFlagsContainer"></div>
            </div>
          </div>

          <div class="editor-actions">
            <button type="button" id="randomizeStatsBtn">
              Randomize stats
            </button>
            <button type="button" id="randomizeTraitsBtn">
              Randomize traits/edits
            </button>
            <button type="button" id="addCustomQueenBtn" class="secondary">
              Add queen
            </button>
            <button type="button" id="updateCustomQueenBtn">
              Update queen
            </button>
            <button type="button" id="removeCustomQueenBtn" class="danger">
              Remove queen
            </button>
          </div>

          <div class="custom-queen-list" id="customQueenList"></div>
        </div>
      </section>
    </div>

    <section class="season-output">
      <h2>Season Output</h2>
      <div id="seasonContainer">
        <p style="font-size:0.85rem; color:#aaa;">
          Once you simulate a season, the results will appear here either as a summary
          or a step-by-step storyline.
        </p>
      </div>
    </section>
  </div>

  <script src="queens.js"></script>
  <script src="challenges.js"></script>
  <script src="mini-challenges.js"></script>
  <script src="runways.js"></script>
  <script src="lipsyncs.js"></script>
  <script src="sim.js"></script>

  <script>
    const DEFAULT_QUEEN_IMAGE = "https://i.imgur.com/kXv2EFQ.png";

    const modeSelect = document.getElementById("modeSelect");
    const viewSelect = document.getElementById("viewSelect");
    const immunityToggle = document.getElementById("immunityToggle");
    const doubleTwistsToggle = document.getElementById("doubleTwistsToggle");
    const simulateBtn = document.getElementById("simulateButton");
    const seasonContainer = document.getElementById("seasonContainer");
    const topToolbar = document.getElementById("topToolbar");

    // Cast builder elements
    const queenSearchInput = document.getElementById("queenSearchInput");
    const searchResultsEl = document.getElementById("searchResults");
    const castSizeRange = document.getElementById("castSizeRange");
    const castSizeLabel = document.getElementById("castSizeLabel");
    const castCountLabel = document.getElementById("castCountLabel");

    const castListEl = document.getElementById("castList");
    const castEmptyHintEl = document.getElementById("castEmptyHint");

    // Custom queen editor elements
    const customNameInput = document.getElementById("customName");
    const customImageUrlInput = document.getElementById("customImageUrl");
    const statActing = document.getElementById("statActing");
    const statComedy = document.getElementById("statComedy");
    const statDance = document.getElementById("statDance");
    const statDesign = document.getElementById("statDesign");
    const statImprov = document.getElementById("statImprov");
    const statRunway = document.getElementById("statRunway");
    const statLipsync = document.getElementById("statLipsync");

    const traitDramaProne = document.getElementById("traitDramaProne");
    const traitProducerFave = document.getElementById("traitProducerFave");

    const editFlagsContainer = document.getElementById("editFlagsContainer");

    const btnRandomizeStats = document.getElementById("randomizeStatsBtn");
    const btnRandomizePersonality = document.getElementById("randomizeTraitsBtn");
    const btnAddCustomQueen = document.getElementById("addCustomQueenBtn");
    const btnUpdateCustomQueen = document.getElementById("updateCustomQueenBtn");
    const btnRemoveCustomQueen = document.getElementById("removeCustomQueenBtn");

    const randomCastBtn = document.getElementById("randomCastBtn");
    const randomCustomCastBtn = document.getElementById("randomCustomCastBtn");
    const loadSampleBtn = document.getElementById("loadSampleBtn");
    const clearCastBtn = document.getElementById("clearCastBtn");

    const customQueenListEl = document.getElementById("customQueenList");

    const CUSTOM_STORAGE_KEY = "drag_sim_custom_queens_v1";
    const EDIT_FLAGS_STORAGE_KEY = "drag_sim_edit_flags_v1";

    let defaultQueens = [];
    let customQueens = [];
    let allQueens = [];
    let currentCast = [];

    const queenNameMap = new Map();

    function normalizeQueenName(name) {
      return (name || "").toLowerCase().trim();
    }

    function rebuildQueenNameMap() {
      queenNameMap.clear();
      allQueens.forEach((q) => {
        if (!q || !q.name) return;
        const key = normalizeQueenName(q.name);
        if (!queenNameMap.has(key)) queenNameMap.set(key, q);
      });
    }

    function getQueenByNameGuess(rawName) {
      if (!rawName) return null;
      let key = normalizeQueenName(rawName.replace(/[.!?…]+$/u, ""));
      let q = queenNameMap.get(key);
      if (q) return q;
      // Try stripping leading "Winner ", "High ", etc. that may sneak in
      key = key.replace(/^(winner|high|low|bottom|safe|sashay away|shantay you stay|mini-challenge winner)\s+/i, "").trim();
      q = queenNameMap.get(key);
      if (q) return q;
      // Try stripping leading "the "
      if (key.startsWith("the ")) {
        key = key.slice(4);
        q = queenNameMap.get(key);
        if (q) return q;
      }
      return null;
    }

    const editCheckboxes = new Map();
    let EDIT_FLAGS_LIST = [];

    function slugify(name) {
      return (
        name
          .toLowerCase()
          .replace(/[^a-z0-9]+/g, "-")
          .replace(/^-|-$/g, "") || "queen-" + Date.now()
      );
    }

    function loadCustomQueens() {
      try {
        const raw = localStorage.getItem(CUSTOM_STORAGE_KEY);
        if (!raw) return [];
        const parsed = JSON.parse(raw);
        if (!Array.isArray(parsed)) return [];
        return parsed.map((q) => ({
          ...q,
          id: q.id || slugify(q.name || "queen"),
          imageUrl:
            (q.imageUrl && q.imageUrl.trim()) || DEFAULT_QUEEN_IMAGE,
        }));
      } catch (e) {
        console.error("Failed to load custom queens:", e);
        return [];
      }
    }

    function saveCustomQueens(list) {
      try {
        localStorage.setItem(CUSTOM_STORAGE_KEY, JSON.stringify(list));
      } catch (e) {
        console.error("Failed to save custom queens:", e);
      }
    }

    function loadEditFlags() {
      try {
        const raw = localStorage.getItem(EDIT_FLAGS_STORAGE_KEY);
        if (!raw) return [];
        const parsed = JSON.parse(raw);
        if (!Array.isArray(parsed)) return [];
        return parsed;
      } catch (e) {
        console.error("Failed to load edit flags:", e);
        return [];
      }
    }

    function saveEditFlags(flags) {
      try {
        localStorage.setItem(EDIT_FLAGS_STORAGE_KEY, JSON.stringify(flags));
      } catch (e) {
        console.error("Failed to save edit flags:", e);
      }
    }

    function initEditFlagCheckboxes() {
      EDIT_FLAGS_LIST = Array.isArray(window.ALL_EDIT_FLAGS)
        ? window.ALL_EDIT_FLAGS
        : [
            "front_runner",
            "late_bloomer",
            "lip_sync_assassin",
            "fan_favorite",
            "villain",
            "robbed",
            "underestimated",
            "messy"
          ];
      editCheckboxes.clear();
      editFlagsContainer.innerHTML = "";
      EDIT_FLAGS_LIST.forEach((flag) => {
        const id = "edit_flag_" + flag;
        const label = document.createElement("label");
        label.className = "edit-flag-label";
        const cb = document.createElement("input");
        cb.type = "checkbox";
        cb.id = id;
        cb.value = flag;
        label.appendChild(cb);
        label.appendChild(document.createTextNode(" " + flag.replace(/_/g, " ")));
        editFlagsContainer.appendChild(label);
        editCheckboxes.set(flag, cb);
      });
    }

    function getSelectedEditFlags() {
      const flags = [];
      editCheckboxes.forEach((cb, flag) => {
        if (cb.checked) flags.push(flag);
      });
      return flags;
    }

    function setSelectedEditFlags(list) {
      const set = new Set(list || []);
      editCheckboxes.forEach((cb, flag) => {
        cb.checked = set.has(flag);
      });
    }

    function buildQueenFromForm(existingId) {
      const name = (customNameInput.value || "").trim();
      if (!name) {
        alert("Please enter a name for the queen.");
        return null;
      }
      const id = existingId || slugify(name);

      function clampStat(v) {
        const n = parseInt(v, 10);
        if (isNaN(n)) return 5;
        return Math.max(0, Math.min(10, n));
      }

      const stats = {
        acting: clampStat(statActing.value),
        comedy: clampStat(statComedy.value),
        dance: clampStat(statDance.value),
        design: clampStat(statDesign.value),
        improv: clampStat(statImprov.value),
        runway: clampStat(statRunway.value),
        lipsync: clampStat(statLipsync.value),
      };

      const traits = {
        dramaProne: !!traitDramaProne.checked,
        producerFave: !!traitProducerFave.checked,
        edits: getSelectedEditFlags(),
      };

      const imageUrl =
        (customImageUrlInput.value && customImageUrlInput.value.trim()) ||
        DEFAULT_QUEEN_IMAGE;

      return {
        id,
        name,
        imageUrl,
        stats,
        traits,
        source: "custom",
      };
    }

    function resetCustomForm() {
      customNameInput.value = "";
      customImageUrlInput.value = "";
      [
        statActing,
        statComedy,
        statDance,
        statDesign,
        statImprov,
        statRunway,
        statLipsync,
      ].forEach((el) => (el.value = ""));
      traitDramaProne.checked = false;
      traitProducerFave.checked = false;
      setSelectedEditFlags([]);
      customNameInput.dataset.editingId = "";
    }

    function randomStat() {
      return Math.floor(Math.random() * 11);
    }

    function randomTrait() {
      return Math.random() < 0.5;
    }

    function randomEdits() {
      const flags = [];
      const available = [...EDIT_FLAGS_LIST];
      const count = Math.floor(Math.random() * 3);
      for (let i = 0; i < count && available.length; i++) {
        const idx = Math.floor(Math.random() * available.length);
        flags.push(available.splice(idx, 1)[0]);
      }
      return flags;
    }

    btnRandomizeStats.addEventListener("click", () => {
      statActing.value = randomStat();
      statComedy.value = randomStat();
      statDance.value = randomStat();
      statDesign.value = randomStat();
      statImprov.value = randomStat();
      statRunway.value = randomStat();
      statLipsync.value = randomStat();
    });

    btnRandomizePersonality.addEventListener("click", () => {
      // Traits
      traitDramaProne.checked = Math.random() < 0.35;
      traitProducerFave.checked = Math.random() < 0.2;

      // Edits: clear, then pick 0–3 random ones
      editCheckboxes.forEach((cb) => (cb.checked = false));

      if (!EDIT_FLAGS_LIST.length) return;
      const maxEdits = 3;
      const count = Math.floor(Math.random() * (maxEdits + 1));
      const pool = [...EDIT_FLAGS_LIST];
      for (let i = 0; i < count && pool.length; i++) {
        const idx = Math.floor(Math.random() * pool.length);
        const flag = pool.splice(idx, 1)[0];
        const cb = editCheckboxes.get(flag);
        if (cb) cb.checked = true;
      }
    });

    function addCustomQueenFromForm() {
      const q = buildQueenFromForm();
      if (!q) return;

      const existing = customQueens.find((c) => c.id === q.id);
      if (existing) {
        if (
          !confirm(
            "A custom queen with this ID already exists. Overwrite that queen?"
          )
        ) {
          return;
        }
        const idx = customQueens.findIndex((c) => c.id === q.id);
        customQueens[idx] = q;
      } else {
        customQueens.push(q);
      }

      saveCustomQueens(customQueens);
      allQueens = [...defaultQueens, ...customQueens];
      rebuildQueenNameMap();
      renderCustomQueenList();
      renderCustomQueenSelect();
      renderSearchResults(queenSearchInput.value);
    }

    function updateCustomQueenFromForm() {
      const editingId = customNameInput.dataset.editingId;
      if (!editingId) {
        alert("Select a custom queen to update.");
        return;
      }
      const q = buildQueenFromForm(editingId);
      if (!q) return;

      const idx = customQueens.findIndex((c) => c.id === editingId);
      if (idx === -1) {
        alert("Could not find that custom queen in the list.");
        return;
      }

      customQueens[idx] = q;
      saveCustomQueens(customQueens);
      allQueens = [...defaultQueens, ...customQueens];
      rebuildQueenNameMap();
      renderCustomQueenList();
      renderCustomQueenSelect();
      renderSearchResults(queenSearchInput.value);
      resetCustomForm();
    }

    function removeCustomQueen() {
      const editingId = customNameInput.dataset.editingId;
      if (!editingId) {
        alert("Select a custom queen to remove.");
        return;
      }
      if (
        !confirm(
          "Are you sure you want to remove this custom queen? This cannot be undone."
        )
      ) {
        return;
      }
      customQueens = customQueens.filter((q) => q.id !== editingId);
      saveCustomQueens(customQueens);
      allQueens = [...defaultQueens, ...customQueens];
      rebuildQueenNameMap();
      currentCast = currentCast.filter((q) => q.source !== "custom" || q.id !== editingId);
      renderCustomQueenList();
      renderCustomQueenSelect();
      renderCastList();
      renderSearchResults(queenSearchInput.value);
      resetCustomForm();
    }

    btnAddCustomQueen.addEventListener("click", addCustomQueenFromForm);
    btnUpdateCustomQueen.addEventListener("click", updateCustomQueenFromForm);
    btnRemoveCustomQueen.addEventListener("click", removeCustomQueen);

    function renderCustomQueenList() {
      customQueenListEl.innerHTML = "";
      if (!customQueens.length) {
        const p = document.createElement("p");
        p.textContent = "No custom queens yet.";
        p.style.fontSize = "0.8rem";
        p.style.color = "#aaa";
        customQueenListEl.appendChild(p);
        return;
      }
      customQueens.forEach((q) => {
        const row = document.createElement("div");
        row.className = "custom-queen-row";
        row.dataset.id = q.id;

        const main = document.createElement("div");
        main.className = "custom-queen-main";

        const nameSpan = document.createElement("span");
        nameSpan.className = "custom-queen-name";
        nameSpan.textContent = q.name;
        main.appendChild(nameSpan);

        const statsSpan = document.createElement("span");
        statsSpan.className = "custom-queen-stats";
        const s = q.stats || {};
        statsSpan.textContent = `A${s.acting ?? 0} / C${s.comedy ?? 0} / D${s.dance ?? 0} / De${
          s.design ?? 0
        } / I${s.improv ?? 0} / R${s.runway ?? 0} / L${s.lipsync ?? 0}`;
        main.appendChild(statsSpan);

        const traits = q.traits || {};
        const tBits = [];
        if (traits.dramaProne) tBits.push("drama-prone");
        if (traits.producerFave) tBits.push("producer favorite");
        if (Array.isArray(traits.edits) && traits.edits.length) {
          tBits.push("edits: " + traits.edits.join(", "));
        }
        if (tBits.length) {
          const traitSpan = document.createElement("span");
          traitSpan.className = "custom-queen-stats";
          traitSpan.textContent = tBits.join(" • ");
          main.appendChild(traitSpan);
        }

        row.appendChild(main);

        const actions = document.createElement("div");
        actions.className = "custom-queen-actions";

        const editBtn = document.createElement("button");
        editBtn.textContent = "Edit";
        editBtn.addEventListener("click", () => {
          loadCustomQueenIntoForm(q);
        });
        actions.appendChild(editBtn);

        const addBtn = document.createElement("button");
        addBtn.textContent = "Add to cast";
        addBtn.addEventListener("click", () => {
          addQueenToCast(q.id);
        });
        actions.appendChild(addBtn);

        row.appendChild(actions);
        customQueenListEl.appendChild(row);
      });
    }

    function loadCustomQueenIntoForm(q) {
      customNameInput.value = q.name || "";
      customNameInput.dataset.editingId = q.id;
      customImageUrlInput.value =
        q.imageUrl && q.imageUrl !== DEFAULT_QUEEN_IMAGE ? q.imageUrl : "";

      const s = q.stats || {};
      statActing.value = s.acting ?? "";
      statComedy.value = s.comedy ?? "";
      statDance.value = s.dance ?? "";
      statDesign.value = s.design ?? "";
      statImprov.value = s.improv ?? "";
      statRunway.value = s.runway ?? "";
      statLipsync.value = s.lipsync ?? "";

      const traits = q.traits || {};
      traitDramaProne.checked = !!traits.dramaProne;
      traitProducerFave.checked = !!traits.producerFave;

      setSelectedEditFlags(traits.edits || []);
    }

    function getCastLimit() {
      const val = parseInt(castSizeRange.value, 10);
      if (isNaN(val)) return 12;
      return Math.min(16, Math.max(6, val));
    }

    function syncCastSizeLabel() {
      castSizeLabel.textContent = getCastLimit();
    }

    castSizeRange.addEventListener("input", syncCastSizeLabel);

    function updateCastCount() {
      castCountLabel.textContent = currentCast.length;
      castEmptyHintEl.style.display = currentCast.length ? "none" : "block";
    }

    function pickRandomQueens(sourceList, n) {
      const pool = [...sourceList];
      const out = [];
      while (pool.length && out.length < n) {
        const idx = Math.floor(Math.random() * pool.length);
        out.push(pool.splice(idx, 1)[0]);
      }
      return out;
    }

    function addQueenToCast(id, options) {
      const opts = options || {};
      const allowDuplicate = !!opts.allowDuplicate;
      const limit = getCastLimit();
      // Always respect the cast limit, even for duplicates
      if (currentCast.length >= limit) return;

      const existing = currentCast.find(q => q.id === id);
      const base = allQueens.find(q => q.id === id);
      if (!base) return;

      let q;
      if (allowDuplicate) {
        // Clone with a new id so the cast can hold multiple copies
        q = {
          ...base,
          id: base.id + "_copy_" + Date.now() + "_" + Math.floor(Math.random() * 1000)
        };
      } else {
        q = base;
      }

      if (existing && !allowDuplicate) {
        // Already in the cast; do nothing
        return;
      }

      currentCast.push(q);
      updateCastCount();
      renderCastList();
      renderSearchResults(queenSearchInput.value);
    }

    function removeQueenFromCastIndex(index) {
      if (index < 0 || index >= currentCast.length) return;
      currentCast.splice(index, 1);
      updateCastCount();
      renderCastList();
      renderSearchResults(queenSearchInput.value);
    }

    function renderCastList() {
      castListEl.innerHTML = "";
      if (!currentCast.length) {
        castEmptyHintEl.style.display = "block";
        return;
      }
      castEmptyHintEl.style.display = "none";

      currentCast.forEach((q, index) => {
        const card = document.createElement("div");
        card.className = "cast-queen-card";
      
        const img = document.createElement("img");
        img.src = q.imageUrl || DEFAULT_QUEEN_IMAGE;
        img.alt = q.name;
        card.appendChild(img);
      
        const name = document.createElement("div");
        name.className = "cast-queen-name";
        name.textContent = q.name;
        card.appendChild(name);
      
        const meta = document.createElement("div");
        meta.className = "cast-queen-meta";
        meta.textContent = q.source === "custom" ? "Custom queen" : "Predefined";
        card.appendChild(meta);
      
        const removeBtn = document.createElement("button");
        removeBtn.textContent = "Remove";
        removeBtn.style.marginTop = "0.35rem";
        removeBtn.style.borderRadius = "999px";
        removeBtn.style.border = "1px solid #444";
        removeBtn.style.background = "#242424";
        removeBtn.style.color = "#eee";
        removeBtn.style.fontSize = "0.75rem";
        removeBtn.style.padding = "0.2rem 0.7rem";
        removeBtn.style.cursor = "pointer";
        removeBtn.addEventListener("click", () => removeQueenFromCastIndex(index));
        card.appendChild(removeBtn);
      
        castListEl.appendChild(card);
      });
    }

    function renderSearchResults(query) {
      const term = (query || "").toLowerCase().trim();
      searchResultsEl.innerHTML = "";

      if (!allQueens.length) return;

      if (!term) {
        const p = document.createElement("p");
        p.textContent = "Start typing to search queens.";
        p.style.fontSize = "0.8rem";
        p.style.color = "#aaa";
        searchResultsEl.appendChild(p);
        return;
      }

      const filtered = allQueens.filter((q) => {
        return q.name.toLowerCase().includes(term);
      });

      if (!filtered.length) {
        const p = document.createElement("p");
        p.textContent = "No queens found.";
        p.style.fontSize = "0.8rem";
        p.style.color = "#aaa";
        searchResultsEl.appendChild(p);
        return;
      }

      filtered.forEach((q) => {
        const card = document.createElement("div");
        card.className = "search-result-card";
        card.dataset.id = q.id;

        const title = document.createElement("div");
        title.textContent = q.name;
        title.style.fontWeight = "600";
        card.appendChild(title);

        const img = document.createElement("img");
        img.src = q.imageUrl || DEFAULT_QUEEN_IMAGE;
        img.alt = q.name;
        img.style.width = "64px";
        img.style.height = "64px";
        img.style.borderRadius = "50%";
        img.style.objectFit = "cover";
        img.style.border = "2px solid #ff4081";
        img.style.boxShadow = "0 0 0 1px #000";
        img.style.margin = "0.25rem auto 0.35rem";
        img.style.display = "block";
        card.appendChild(img);

        const meta = document.createElement("div");
        meta.style.fontSize = "0.75rem";
        meta.style.color = "#bbb";
        meta.textContent = q.source === "custom" ? "Custom queen" : "Predefined";
        card.appendChild(meta);

        card.addEventListener("click", (e) => {
          const allowDup = e.shiftKey || e.altKey;
          addQueenToCast(q.id, { allowDuplicate: allowDup });
        });

        searchResultsEl.appendChild(card);
      });
    }

    queenSearchInput.addEventListener("input", () => {
      renderSearchResults(queenSearchInput.value);
    });

    randomCastBtn.addEventListener("click", () => {
      if (!defaultQueens.length) return;
      const size = getCastLimit();
      currentCast = pickRandomQueens(defaultQueens, size);
      updateCastCount();
      renderCastList();
      renderSearchResults(queenSearchInput.value);
    });

    randomCustomCastBtn.addEventListener("click", () => {
      if (!customQueens.length) return;
      const size = getCastLimit();
      currentCast = pickRandomQueens(customQueens, size);
      updateCastCount();
      renderCastList();
      renderSearchResults(queenSearchInput.value);
    });

    loadSampleBtn.addEventListener("click", () => {
      const sampleIds = (typeof SAMPLE_CAST !== "undefined" && Array.isArray(SAMPLE_CAST))
        ? SAMPLE_CAST
        : (Array.isArray(window.SAMPLE_CAST) ? window.SAMPLE_CAST : []);
      if (sampleIds.length) {
        currentCast = sampleIds.map((id) => {
          const q = allQueens.find((qq) => qq.id === id);
          return (
            q || {
              id,
              name: id,
              imageUrl: DEFAULT_QUEEN_IMAGE,
              source: "unknown",
            }
          );
        });
      } else {
        const limit = getCastLimit();
        currentCast = defaultQueens.slice(0, limit);
      }
      updateCastCount();
      renderCastList();
      renderSearchResults(queenSearchInput.value);
    });

    clearCastBtn.addEventListener("click", () => {
      if (
        currentCast.length &&
        !confirm("Clear the entire cast? This can't be undone.")
      ) {
        return;
      }
      currentCast = [];
      updateCastCount();
      renderCastList();
      renderSearchResults(queenSearchInput.value);
    });

    // =========================
    // Season simulation handling
    // =========================

    let currentSteps = [];
    let currentStepIndex = 0;
    let lastSeasonLog = "";
    let seasonEpisodeCount = 0;
    let trackRecordData = null;
    let seasonEpisodeResults = null;
    let currentViewMode = "summary";

    function enterStoryMode() {
      const builder = document.getElementById("builderScreen");
      if (builder) builder.classList.add("hidden");
    
      // Hide all top settings during season progression
      if (topToolbar) topToolbar.classList.add("hidden");
    
      // Optional: lets us tighten spacing via CSS if you want
      document.body.classList.add("story-mode");
    }
    
    function exitStoryMode() {
      const builder = document.getElementById("builderScreen");
      if (builder) builder.classList.remove("hidden");
    
      // Restore settings when back in cast building
      if (topToolbar) topToolbar.classList.remove("hidden");
      document.body.classList.remove("story-mode");
    
      seasonContainer.innerHTML = `
        <p style="font-size:0.85rem; color:#aaa;">
          Once you simulate a season, the results will appear here either as a summary
          or a step-by-step storyline.
        </p>
      `;
      window.scrollTo({ top: 0, behavior: "smooth" });
    }

    function goBackToSetup() {
      currentSteps = [];
      currentStepIndex = 0;
      exitStoryMode();
    }

    function getOptionsFromUI() {
      return {
        mode: modeSelect.value === "chaos" ? "chaos" : "normal",
        view: viewSelect.value === "full" ? "full" : "summary",
        enableImmunity: !!immunityToggle.checked,
        enableDoubleTwists: !!doubleTwistsToggle.checked,
      };
    }

    function getEffectiveCast() {
      if (currentCast.length) return currentCast;
      const size = getCastLimit();
      const pool = defaultQueens.length ? defaultQueens : allQueens;
      return pickRandomQueens(pool, size);
    }

    function simulateSeasonFromUI() {
      const simFn = window.simulateSeason || (typeof simulateSeason === "function" ? simulateSeason : null);
      if (typeof simFn !== "function") {
        alert("simulateSeason is not defined. Please check sim.js is loaded.");
        return;
      }

      const queens = getEffectiveCast();
      if (!queens.length) {
        alert("No queens available to simulate a season.");
        return;
      }

      const options = getOptionsFromUI();
      currentViewMode = options.view;
      const result = simFn(queens, options);
      const log = typeof result === "string" ? result : result.log || "";
      const meta = typeof result === "string" ? null : result;

      lastSeasonLog = log || "";
      // Track record data may come back either at top-level (newer sim.js) or inside meta (older builds).
      trackRecordData =
        (result && result.trackRecord && Array.isArray(result.trackRecord.episodes)) ? result.trackRecord :
        (meta && meta.trackRecord && Array.isArray(meta.trackRecord.episodes)) ? meta.trackRecord :
        null;
      seasonEpisodeResults =
        (result && Array.isArray(result.episodeResults)) ? result.episodeResults :
        (meta && Array.isArray(meta.episodeResults)) ? meta.episodeResults :
        null;
enterStoryMode(); // hide builder + toolbar while showing results
      
      if (options.view === "full") {
        renderSeasonFull(lastSeasonLog);
      } else {
        renderSeasonSummary(lastSeasonLog);
      }

      // Scroll to the output so it feels like a new "page"
      window.scrollTo({ top: 0, behavior: "smooth" });
    }

    simulateBtn.addEventListener("click", simulateSeasonFromUI);

    // =========================
    // Parsing season logs
    // =========================

    function parseSeasonLog(logText) {
      const lines = (logText || "").split(/\r?\n/);
      const header = [];
      const episodes = [];
      const finale = [];

      let currentBlock = header;
      let currentEpisode = null;

      function startNewEpisode(titleLine) {
        if (currentEpisode) {
          episodes.push(currentEpisode);
        }
        currentEpisode = {
          title: titleLine,
          lines: [titleLine],
        };
      }

      for (const line of lines) {
        if (line.startsWith("========== Episode")) {
          startNewEpisode(line);
        } else if (line.startsWith("========== Final 3")) {
          // Final 3 section belongs to the finale block, not the last episode.
          if (currentEpisode) {
            episodes.push(currentEpisode);
            currentEpisode = null;
          }
          currentBlock = finale;
          currentBlock.push(line);
        } else if (line.startsWith("========== Grand Finale")) {
          if (currentEpisode) {
            episodes.push(currentEpisode);
            currentEpisode = null;
          }
          currentBlock = finale;
          currentBlock.push(line);
        } else if (currentEpisode) {
          currentEpisode.lines.push(line);
        } else {
          currentBlock.push(line);
        }
      }

      if (currentEpisode) {
        episodes.push(currentEpisode);
      }

      return { header, episodes, finale };
    }

    function filterHeader(lines) {
      return (lines || []).filter((line) => {
        if (!line.trim()) return false;
        if (line.startsWith("==========")) return false;
        if (line.startsWith("Season:")) return true;
        if (line.startsWith("Cast:")) return true;
        if (line.startsWith("Format:")) return true;
        return false;
      });
    }

    // Strip out raw numeric score blocks from episodes
    function filterEpisode(lines) {
      const out = [];
      let skippingScores = false;

      for (const line of lines || []) {
        const trimmed = line.trim();
        if (!trimmed) {
          // blank lines reset score-skipping
          skippingScores = false;
          continue;
        }

        // Headers that introduce a numeric score table
        if (
          /^Mini-challenge scores:/i.test(trimmed) ||
          /^Scores this week:/i.test(trimmed) ||
          /^Main challenge scores:/i.test(trimmed) ||
          /^Runway scores:/i.test(trimmed) ||
          /^Total scores:/i.test(trimmed)
        ) {
          skippingScores = true;
          continue;
        }

        // While skipping, ignore lines until we hit something clearly narrative.
        if (skippingScores) {
          if (
            /^Results:/i.test(trimmed) ||
            /^Mini-challenge winner:/i.test(trimmed) ||
            /^Winner:/i.test(trimmed) ||
            /^Based on tonight's performances/i.test(trimmed)
          ) {
            skippingScores = false;
          } else {
            continue;
          }
        }

        out.push(line);
      }
      return out;
    }

    function parseEpisodeSections(filteredLines) {
      // Skip the title line if present
      const lines = filteredLines.slice(1);
      const maxi = [];
      const judging = [];
      const bringBack = [];
      const lipsync = [];
      const results = [];
    
      // --- Pass 1: try the old marker-based format (backwards compatible) ---
      let section = "none";
      let sawOldMarkers = false;
    
      for (const line of lines) {
        const trimmed = line.trim();
        if (!trimmed) continue;
    
        if (trimmed.startsWith("The queens will") || trimmed.startsWith("Queens' performances")) {
          section = "maxi";
          maxi.push(line);
          sawOldMarkers = true;
          continue;
        }
        if (trimmed.startsWith("Based on tonight's performances")) {
          section = "judging";
          judging.push(line);
          sawOldMarkers = true;
          continue;
        }
        if (trimmed.startsWith("Ladies, I've made some decisions")) {
          section = "bringBack";
          bringBack.push(line);
          sawOldMarkers = true;
          continue;
        }
        if (trimmed.startsWith("The time has come")) {
          section = "lipsync";
          lipsync.push(line);
          sawOldMarkers = true;
          continue;
        }
        if (trimmed.startsWith("I've made my decision")) {
          section = "results";
          results.push(line);
          sawOldMarkers = true;
          continue;
        }
    
        if (section === "maxi") maxi.push(line);
        else if (section === "judging") judging.push(line);
        else if (section === "bringBack") bringBack.push(line);
        else if (section === "lipsync") lipsync.push(line);
        else if (section === "results") results.push(line);
      }
    
      if (sawOldMarkers) {
        return { maxi, judging, bringBack, lipsync, results };
      }
    
      // --- Pass 2: new-style format (current sim.js logs) ---
      // Structure is roughly:
      //   Results:
      //     Winner: ...
      //     High: ...
      //     Low: ...
      //     Bottom: A vs B
      //     [SPECIAL TWIST...]
      //     Shantay you stay: ...
      //     Sashay away: ...
    
      let inResultsBlock = false;
      maxi.length = judging.length = bringBack.length = lipsync.length = results.length = 0;
    
      for (const line of lines) {
        const trimmed = line.trim();
        if (!trimmed) continue;
    
        if (/^Results:/i.test(trimmed)) {
          inResultsBlock = true;
          continue;
        }
    
        if (!inResultsBlock) {
          // Anything before "Results:" we treat as maxi-challenge flavour
          maxi.push(line);
          continue;
        }
    
        if (/^Winner:/i.test(trimmed) || /^High:/i.test(trimmed) || /^Low:/i.test(trimmed)) {
          judging.push(line);
        } else if (/^Bottom:/i.test(trimmed)) {
          bringBack.push(line);
        } else if (/Shantay you stay/i.test(trimmed)) {
          lipsync.push(line);
        } else if (/Sashay away:/i.test(trimmed) || /^SPECIAL TWIST:/i.test(trimmed)) {
          results.push(line);
        } else {
          // Anything else inside the Results block goes into results as a catch-all
          results.push(line);
        }
      }
    
      return { maxi, judging, bringBack, lipsync, results };
    }

    // Now robust to "Winner:", "High:", "Bottom: A vs. B", etc.
    function parseQueenNamesFromLine(line) {
      if (!line) return [];
      let segment = line.trim();

      // Strip leading labels
      segment = segment.replace(/^(Winner|High|Low|Bottom|Safe|Mini-challenge winner|Sashay away|Shantay you stay):\s*/i, "");

      // Turn "X vs Y" into "X, Y"
      segment = segment.replace(/\s+vs\.?\s+/i, ", ");

      // Chop off trailing narrative phrases
      const cutMarkers = [
        " had a great performance",
        " had a good performance",
        " slayed the challenge",
        " bombed the challenge",

        " had a bad performance",
        " had a great lipsync",
        " had a good lipsync",
        " had a bad lipsync",
        " won the mini-challenge",
        " won the mini challenge",
        " you're the bottoms of the week",
        " you're safe",
        " you are safe",
        " I'm sorry my dears",
        " shantay you stay",
        " sashay away",
        " condragulations",
      ];
      for (const marker of cutMarkers) {
        const idx = segment.toLowerCase().indexOf(marker);
        if (idx !== -1) {
          segment = segment.slice(0, idx);
          break;
        }
      }

      // Replace "and" with commas so "A and B" parses as two names.
      segment = segment.replace(/\band\b/gi, ",");

      const parts = segment
        .split(",")
        .map((p) => p.trim())
        .filter(Boolean);

      return parts;
    }


    // Format a list of queen names as: "A", "A & B", or "A, B & C" (no trailing comma)
    function formatNameList(names) {
      const clean = (names || []).map(n => (n || "").trim()).filter(Boolean);
      if (clean.length === 0) return "";
      if (clean.length === 1) return clean[0];
      if (clean.length === 2) return `${clean[0]} & ${clean[1]}`;
      return `${clean.slice(0, -1).join(", ")} & ${clean[clean.length - 1]}`;
    }


    function renderQueenRow(names, caption, card, opts = {}) {
      if (!names || !names.length) return;
      const rowWrap = document.createElement("div");
      rowWrap.className = "queen-row" + (opts && opts.neutral ? " neutral" : "");

      names.forEach((raw) => {
        const q = getQueenByNameGuess(raw);
        const cell = document.createElement("div");
        cell.className = "queen-avatar";

        const img = document.createElement("img");
        img.src = (q && q.imageUrl) || DEFAULT_QUEEN_IMAGE;
        img.alt = q ? q.name : raw;
        cell.appendChild(img);
rowWrap.appendChild(cell);
      });

      card.appendChild(rowWrap);

      if (caption) {
        const cap = document.createElement("div");
        cap.className = "queen-row-caption";
        cap.textContent = caption;
        card.appendChild(cap);
      }
    }


    function shouldAddRunwayStep(epNum) {
      // Runway gets its own segment for most challenges.
      // We *do not* add a separate runway segment for runway-centric challenges like balls/makeovers/design.
      const epIdx = Math.max(0, (epNum || 1) - 1);
      const epRes = (seasonEpisodeResults && seasonEpisodeResults[epIdx]) ? seasonEpisodeResults[epIdx] : null;
      const id = epRes && epRes.challengeId ? String(epRes.challengeId).toLowerCase() : "";
      // If we don't have structured results yet, default to adding runway (it won't harm anything).
      if (!id) return true;
      const runwayCentric = new Set(["ball", "makeover", "design", "runway", "fashion"]);
      if (runwayCentric.has(id)) return false;
      return true;
    }

    
function renderRunwayStep(step, card) {
  const wrap = document.createElement("div");
  wrap.className = "maxi-step results-step";

  const title = document.createElement("div");
  title.className = "maxi-title";
  title.textContent = "Runway!";
  wrap.appendChild(title);

  const intro = document.createElement("div");
  intro.className = "maxi-intro";
  intro.textContent = "The queens will bring it to the runway!";
  wrap.appendChild(intro);

  const epIdx = Math.max(0, (step.epNum || 1) - 1);
  const epRes = (seasonEpisodeResults && seasonEpisodeResults[epIdx]) ? seasonEpisodeResults[epIdx] : null;

  // Category line
  const categoryLine = document.createElement("div");
  categoryLine.className = "maxi-intro";
  categoryLine.style.marginTop = "-0.35rem";
  categoryLine.style.fontSize = "0.95rem";
  const cat = epRes && epRes.runwayCategory ? epRes.runwayCategory : null;
  categoryLine.textContent = cat ? `Category is... ${cat}.` : "Category is... (unknown).";
  wrap.appendChild(categoryLine);

  const buckets = [
    { key: "slayed", label: "slayed the runway!", rowClass: "perf-slayed" },
    { key: "great",  label: "had a great runway!", rowClass: "perf-great" },
    { key: "good",   label: "had a good runway.", rowClass: "perf-good" },
    { key: "bad",    label: "had a bad runway…", rowClass: "perf-bad" },
    { key: "bombed", label: "bombed the runway…", rowClass: "perf-bombed" },
  ];

  const grouped = new Map(buckets.map(b => [b.key, []]));

  // Prefer structured runway tiers from sim.js
  if (epRes && Array.isArray(epRes.runwayTiers) && epRes.runwayTiers.length) {
    for (const t of epRes.runwayTiers) {
      if (!t || !t.tier || !t.name) continue;
      const key = String(t.tier).toLowerCase();
      if (!grouped.has(key)) continue;
      grouped.get(key).push(t);
    }
  }

  let renderedAny = false;

  buckets.forEach((b) => {
    const entries = grouped.get(b.key) || [];
    if (!entries.length) return;
    renderedAny = true;

    const rowWrap = document.createElement("div");
    rowWrap.className = `queen-row perf-row ${b.rowClass}`;

    entries.forEach((entry) => {
      const raw = (entry && entry.name) ? entry.name : String(entry);
      const q = getQueenByNameGuess(raw);

      const cell = document.createElement("div");
      cell.className = "queen-avatar";

      const img = document.createElement("img");
      img.src = (q && q.imageUrl) || DEFAULT_QUEEN_IMAGE;
      img.alt = q ? q.name : raw;
      cell.appendChild(img);
rowWrap.appendChild(cell);
    });

    wrap.appendChild(rowWrap);

    const cap = document.createElement("div");
    cap.className = "perf-caption";
    const namesForCaption = entries.map(e => (e && e.name) ? e.name : String(e));
    cap.textContent = `${formatNameList(namesForCaption)} ${b.label}`;
    wrap.appendChild(cap);
  });

  if (!renderedAny) {
    const p = document.createElement("div");
    p.style.color = "#ccc";
    p.style.marginTop = "0.5rem";
    p.textContent = "No runway tiers were available for this episode (check that sim.js is returning runwayTiers).";
    wrap.appendChild(p);
  }

  card.appendChild(wrap);
}


    function renderQueenRowWithRingClass(names, caption, card, ringClass) {
      if (!names || !names.length) return;
      const rowWrap = document.createElement("div");
      rowWrap.className = "queen-row perf-row " + (ringClass || "perf-safe");

      names.forEach((raw) => {
        const q = getQueenByNameGuess(raw);
        const cell = document.createElement("div");
        cell.className = "queen-avatar";

        const img = document.createElement("img");
        img.src = (q && q.imageUrl) || DEFAULT_QUEEN_IMAGE;
        img.alt = q ? q.name : raw;
        cell.appendChild(img);
rowWrap.appendChild(cell);
      });

      card.appendChild(rowWrap);

      if (caption) {
        const cap = document.createElement("div");
        cap.className = "queen-row-caption";
        cap.textContent = caption;
        card.appendChild(cap);
      }
    }

    function renderBringBackStep(step, card) {
      const wrap = document.createElement("div");
      wrap.className = "maxi-step results-step";

      const intro = document.createElement("div");
      intro.className = "maxi-intro";
      intro.style.fontWeight = "700";
      intro.style.marginBottom = "0.75rem";
      intro.textContent = "Ladies, I've made some decisions...";
      wrap.appendChild(intro);

      const epIdx = Math.max(0, (step.epNum || 1) - 1);
      const epRes = (seasonEpisodeResults && seasonEpisodeResults[epIdx]) ? seasonEpisodeResults[epIdx] : null;
      const tiers = (epRes && Array.isArray(epRes.tiers)) ? epRes.tiers : [];

      const byPlacement = (p) => tiers.filter(t => t && t.placement === p).map(t => t.name);
      const winner = byPlacement("WIN");
      const highs  = byPlacement("HIGH");
      const lows   = byPlacement("LOW");
      const btms   = byPlacement("BTM");

      // Winner reveal
      if (winner.length) {
        renderQueenRowWithRingClass(winner, "", wrap, "perf-win");
        const winText = document.createElement("div");
        winText.className = "perf-caption";
        winText.textContent = `${formatNameList(winner)}, condragulations, you're the winner of today's challenge!`;
        wrap.appendChild(winText);
      }

      // Highs are safe (old sim style)
      if (highs.length) {
        renderQueenRowWithRingClass(highs, "", wrap, "perf-high");
        const highText = document.createElement("div");
        highText.className = "queen-row-caption";
        highText.style.fontSize = "0.95rem";
        highText.style.fontWeight = "650";
        highText.style.color = "#eee";
        highText.style.marginBottom = "0.9rem";
        highText.textContent = `${formatNameList(highs)}, good job this week, you're safe.`;
        wrap.appendChild(highText);
      }

      // Divider before bottoms
      const div = document.createElement("div");
      div.className = "bbm-divider";
      wrap.appendChild(div);

      const bottomGroup = [...lows, ...btms];

      if (bottomGroup.length) {
        // Mixed rings: LOW = orange, BTM = red
        const rowWrap = document.createElement("div");
        rowWrap.className = "queen-row perf-row";

        bottomGroup.forEach((raw) => {
          const q = getQueenByNameGuess(raw);
          const cell = document.createElement("div");
          cell.className = "queen-avatar";

          const img = document.createElement("img");
          img.src = (q && q.imageUrl) || DEFAULT_QUEEN_IMAGE;
          img.alt = q ? q.name : raw;
          // Set ring color per placement
          const isLow = lows.includes(raw);
          img.style.borderColor = isLow ? "#f57c00" : "#c62828";
          cell.appendChild(img);
rowWrap.appendChild(cell);
        });

        wrap.appendChild(rowWrap);

        const bottomsText = document.createElement("div");
        bottomsText.className = "queen-row-caption";
        bottomsText.style.fontSize = "0.95rem";
        bottomsText.style.fontWeight = "650";
        bottomsText.style.color = "#eee";
        bottomsText.style.marginBottom = "0.9rem";
        bottomsText.textContent = `${formatNameList(bottomGroup)}, you're the bottoms of the week...`;
        wrap.appendChild(bottomsText);
      }

      // Dramatic save: usually the LOW queen
      if (lows.length) {
        const saved = [lows[0]];
        renderQueenRowWithRingClass(saved, "", wrap, "perf-low");
        const safeText = document.createElement("div");
        safeText.className = "perf-caption";
        safeText.textContent = `${saved[0]}... you are safe.`;
        wrap.appendChild(safeText);
      }

      // Bottom 2 up for elimination
      if (btms.length) {
        renderQueenRowWithRingClass(btms, "", wrap, "perf-bottom");
        const btmText = document.createElement("div");
        btmText.className = "perf-caption";
        btmText.textContent = `${formatNameList(btms)}, I'm sorry my dears but you are up for elimination.`;
        wrap.appendChild(btmText);
      }

      card.appendChild(wrap);
    }

function renderJudgingStep(step, card) {
  // Mirror the "old simulator" judging: show only the TOPS/BOTTOMS portraits (neutral rings),
  // then list SAFE queens in text.
  const wrap = document.createElement("div");
  wrap.className = "maxi-step results-step";

  const title = document.createElement("div");
  title.className = "maxi-title";
  title.textContent = "Based on tonight's performances...";
  wrap.appendChild(title);

  const epIdx = Math.max(0, (step.epNum || 1) - 1);
  const epRes = (seasonEpisodeResults && seasonEpisodeResults[epIdx]) ? seasonEpisodeResults[epIdx] : null;

  const tiers = (epRes && Array.isArray(epRes.tiers)) ? epRes.tiers : [];
  const topBottom = tiers.filter(t => ["WIN","HIGH","LOW","BTM"].includes(t.placement));
  const safe = tiers.filter(t => t.placement === "SAFE");

  const topBottomNames = topBottom.map(t => t.name);
  const safeNames = safe.map(t => t.name);

  if (topBottomNames.length) {
    const caption = `${formatNameList(topBottomNames)}, you represent the tops and bottoms of the week.`;
    renderQueenRow(topBottomNames, caption, wrap, { neutral: true });
  }

  if (safeNames.length) {
    // If there are a lot of safe queens, listing each line reads better than one mega-sentence.
    safeNames.forEach((n) => {
      const p = document.createElement("p");
      p.className = "judging-safe-line";
      p.textContent = `${n}, you are safe.`;
      wrap.appendChild(p);

      const hr = document.createElement("div");
      hr.className = "judging-divider";
      wrap.appendChild(hr);
    });
    // Remove trailing divider
    const last = wrap.lastElementChild;
    if (last && last.classList && last.classList.contains("judging-divider")) {
      wrap.removeChild(last);
    }
  }

  card.appendChild(wrap);
}



    function buildStepsFromLog(log) {
      const { header, episodes, finale } = parseSeasonLog(log);
      const steps = [];

      // Canonical number of main episodes for track-record table
      seasonEpisodeCount = episodes.length;

      const castLines = filterHeader(header);
      if (castLines.length) {
        steps.push({ type: "cast", lines: castLines });
      }

      episodes.forEach((ep, index) => {
        const filtered = filterEpisode(ep.lines);
        const titleLine = filtered[0] || ep.lines[0] || "";
        const m = titleLine.match(/Episode (\d+) — (.+?) =+/);
        const epNum = m ? parseInt(m[1], 10) : index + 1;
        const epName = m ? m[2] : "Unknown challenge";

        // Basic episode intro
        steps.push({ type: "episode_setup", epNum, name: epName });

        // Mini-challenge
        let miniLines = [];
        let miniName = null;
        let inMini = false;

        for (const line of filtered) {
          const trimmed = line.trim();

          if (trimmed.startsWith("Mini-Challenge —")) {
            inMini = true;
            miniLines.push(line);
            const mm = trimmed.match(/^Mini-Challenge — (.+)$/);
            if (mm) miniName = mm[1];
            continue;
          }

          if (inMini) {
            if (trimmed.startsWith("Results:")) {
              inMini = false;
              continue;
            }
            miniLines.push(line);
          }
        }

        if (miniLines.length) {
          steps.push({
            type: "episode_mini",
            epNum,
            name: epName,
            miniName,
            lines: miniLines.filter((l) => l.trim() !== ""),
          });
        }

        // Maxi / judging / bring-back / lipsync / results
        let { maxi, judging, bringBack, lipsync, results } =
          parseEpisodeSections(filtered);

        // If there were no explicit maxi lines but we *do* have judging/results,
        // create a simple placeholder so the maxi step still exists.
        if (
          (!maxi || !maxi.length) &&
          (judging.length || bringBack.length || lipsync.length || results.length)
        ) {
          maxi = [
            `The queens give it their all in the ${epName} challenge.`,
          ];
        }
  
        if (maxi && maxi.length) {
          steps.push({
            type: "episode_maxi",
            epNum,
            name: epName,
            lines: maxi,
          });

          // Runway as its own segment (most episodes).
          if (shouldAddRunwayStep(epNum)) {
            steps.push({
              type: "episode_runway",
              epNum,
              name: epName,
              lines: [],
            });
          }
        }

        if (judging.length) {
          steps.push({
            type: "episode_judging",
            epNum,
            name: epName,
            lines: judging,
          });
        }

        if (bringBack.length) {
          steps.push({
            type: "episode_bring_back",
            epNum,
            name: epName,
            lines: bringBack,
          });
        }

        if (lipsync.length) {
          steps.push({
            type: "episode_lipsync",
            epNum,
            name: epName,
            lines: lipsync,
          });
        }

        if (results.length) {
          steps.push({
            type: "episode_results",
            epNum,
            name: epName,
            lines: results,
          });
        }
      });

      // Finale / track record summary
      const finaleLines = finale;
      if (finaleLines.length) {
        const idx = finaleLines.findIndex((l) =>
          l.startsWith("========== Grand Finale")
        );
        if (idx > 0) {
          const final3Lines = finaleLines.slice(0, idx).filter((l) => l.trim());
          if (final3Lines.length) steps.push({ type: "final3", lines: final3Lines });
        } else {
          // If for some reason we didn't get a separate Final 3 header, still show something.
          steps.push({ type: "final3", lines: finaleLines.filter((l) => /Final 3/i.test(l) || /track record/i.test(l)) });
        }

        // Grand Finale is rendered as structured steps using episodeResults (no data-dump).
        steps.push({ type: "finale_runway" });
        steps.push({ type: "finale_top2_reveal" });
        steps.push({ type: "finale_lipsync" });
        steps.push({ type: "finale_winner" });
      }

      return steps;
    }

    
function renderLipSyncStep(step, card) {
  const epNum = step.epNum || 1;
  const epIdx = Math.max(0, epNum - 1);
  const epRes = (seasonEpisodeResults && seasonEpisodeResults[epIdx]) ? seasonEpisodeResults[epIdx] : null;

  // Bottom 2 portraits (from placements if available; otherwise fall back to parsing the first queen-row line)
  let bottom2 = [];
  if (epRes && Array.isArray(epRes.tiers)) {
    bottom2 = epRes.tiers.filter(t => t.placement === "BTM").map(t => t.name);
  }
  if (bottom2.length < 2) {
    // Fallback: parse any "Name, ..." lines for the first two unique names.
    const seen = new Set();
    (step.lines || []).forEach(line => {
      const m = String(line).match(/^\s*([^,]+),\s*(.+)$/);
      if (!m) return;
      const name = m[1].trim();
      if (!name || seen.has(name)) return;
      seen.add(name);
    });
    bottom2 = Array.from(seen).slice(0, 2);
  }

  if (bottom2.length) {
    renderQueenRow(bottom2, "", card);
  }

  // Render narration/song lines as plain text (never parsed as queen rows)
  const lines = (step.lines || []).map(l => String(l)).filter(l => l.trim().length);
  const narration = [];
  let songLine = null;

  for (const line of lines) {
    // Skip any "Name, ..." rows (those are handled via structured tiers below)
    if (/^\s*[^,]+,\s*/.test(line)) continue;
    if (line.toLowerCase().includes("lip-sync song")) {
      songLine = line;
      continue;
    }
    narration.push(line);
  }

  if (narration.length) {
    const p = document.createElement("p");
    p.className = "episode-narration";
    p.textContent = narration.join("\n");
    card.appendChild(p);
  }
  if (songLine) {
    const p = document.createElement("p");
    p.className = "episode-song";
    p.textContent = songLine;
    card.appendChild(p);
  }

  // Structured lip-sync outcomes (slayed/great/good/bad/bombed)
  const tierToText = (tier) => {
    switch ((tier || "").toLowerCase()) {
      case "slayed": return "slayed the lipsync!";
      case "great":  return "had a great lipsync!";
      case "good":   return "had a good lipsync.";
      case "bad":    return "had a bad lipsync...";
      case "bombed": return "bombed the lipsync...";
      default:       return "had a lipsync...";
    }
  };

  const lip = epRes && epRes.lipSync ? epRes.lipSync : null;
  const lipTiers = lip && Array.isArray(lip.tiers) ? lip.tiers : [];
  if (lipTiers.length) {
    lipTiers.forEach(t => {
      const name = t.name || t;
      const tier = (t && t.tier) ? t.tier : null;
      renderQueenRow([name], tierToText(tier), card, { neutral: true });
    });
  }
}

function renderResultsStep(step, card) {
  // Post-lip-sync results (Shantay/Sashay/double saves, etc.)
  // Styled to match the "pretty" UI like other steps.
  const wrap = document.createElement("div");
  wrap.className = "maxi-step results-step";
  wrap.style.textAlign = "center";

  const title = document.createElement("div");
  title.className = "maxi-title";
  title.textContent = "Results";
  wrap.appendChild(title);

  const rawLines = (step && step.lines ? step.lines : []);
  const lines = rawLines.map(l => String(l || "").trim()).filter(l => l.length > 0);

  // Decision line (always show for vibe, even if missing in log)
  const decision = document.createElement("div");
  decision.className = "maxi-intro decision-line";
  decision.style.fontWeight = "800";
  decision.textContent = "I've made my decision.";
  wrap.appendChild(decision);

  if (!lines.length) {
    const p = document.createElement("div");
    p.className = "maxi-intro";
    p.style.color = "#aaa";
    p.textContent = "No results data available.";
    wrap.appendChild(p);
    card.appendChild(wrap);
    return;
  }

  const parseAfterColon = (line) => {
    const idx = line.indexOf(":");
    if (idx < 0) return "";
    return line.slice(idx + 1).trim();
  };

  const maybeNames = (s) => {
    if (!s) return [];
    return s
      .split(/&|,|\band\b/gi)
      .map(x => x.trim())
      .filter(Boolean);
  };

  let specialTwist = null;
  let shantay = [];
  let sashay = [];

  for (const l of lines) {
    const lower = l.toLowerCase();

    if (lower.startsWith("special twist:")) {
      specialTwist = l.replace(/^special twist:\s*/i, "").trim();
      continue;
    }

    if (lower.startsWith("shantay you stay:")) {
      shantay = maybeNames(parseAfterColon(l));
      continue;
    }

    if (lower.startsWith("sashay away:")) {
      sashay = maybeNames(parseAfterColon(l));
      continue;
    }
  }

  if (specialTwist) {
    const p = document.createElement("div");
    p.className = "maxi-intro";
    p.style.marginTop = "-0.35rem";
    p.style.marginBottom = "0.85rem";
    p.style.color = "#ff80ab";
    p.style.fontWeight = "700";
    p.textContent = specialTwist;
    wrap.appendChild(p);
  }

  // Shantay
  if (shantay.length) {
    renderQueenRowWithRingClass(shantay, "", wrap, "perf-win");

    const cap = document.createElement("div");
    cap.className = "perf-caption results-caption results-stay";
    cap.textContent = `${formatNameList(shantay)} — Shantay, you stay.`;
    wrap.appendChild(cap);
  }

  // Divider between outcomes
  if (shantay.length && sashay.length) {
    const div = document.createElement("div");
    div.className = "judging-divider";
    div.style.margin = "0.85rem auto";
    div.style.maxWidth = "420px";
    wrap.appendChild(div);
  }

  // Sashay
  if (sashay.length) {
    renderQueenRowWithRingClass(sashay, "", wrap, "perf-bottom");

    const cap = document.createElement("div");
    cap.className = "perf-caption results-caption results-sashay";
    cap.textContent = `${formatNameList(sashay)} — Sashay away.`;
    wrap.appendChild(cap);
  }

  // Fallback: if parsing failed, show raw lines softly
  if (!shantay.length && !sashay.length) {
    const pre = document.createElement("pre");
    pre.textContent = lines.join("\n");
    wrap.appendChild(pre);
  }

  card.appendChild(wrap);
}




// Old-sim style Lip Sync step using structured episodeResults.
// Renders bottom 2, narration, song, and per-queen lip-sync tiers.
function renderLipSyncStep(step, card) {
  const wrap = document.createElement("div");
  wrap.className = "maxi-step results-step";

  const epNum = step.epNum || 1;
  const epIdx = Math.max(0, epNum - 1);
  const epRes = seasonEpisodeResults?.[epIdx] || null;

  // Bottom 2 portraits (neutral intro row)
  let bottom2 = [];
  if (epRes?.tiers) {
    bottom2 = epRes.tiers
      .filter(t => t.placement === "BTM")
      .map(t => t.name);
  }

  if (bottom2.length) {
    renderQueenRow(bottom2, "", wrap, { neutral: true });
  }

  // Narration + song (FILTER OUT old lip-sync result lines)
  const narration = [];
  let songLine = null;

  (step.lines || []).forEach(line => {
    // Capture song reveal
    if (/lip-sync song/i.test(line)) {
      songLine = line;
      return;
    }

    // Ignore legacy lip-sync result lines (now rendered from structured data)
    if (/slayed the lip-sync|had a .*lip-sync|bombed the lip-sync/i.test(line)) {
      return;
    }

    // Ignore comma-based "Queen, did X" patterns
    if (/^\s*[^,]+,\s*/.test(line)) {
      return;
    }

    narration.push(line);
  });

  if (narration.length) {
    const p = document.createElement("div");
    p.className = "maxi-intro";
    p.textContent = narration.join(" ");
    wrap.appendChild(p);
  }

  if (songLine) {
    const p = document.createElement("div");
    p.className = "maxi-intro";
    p.style.fontWeight = "600";
    p.textContent = songLine;
    wrap.appendChild(p);
  }

  // Lip-sync tiers (STRUCTURED DATA — single source of truth)
  const tierLabel = {
    slayed: "slayed the lipsync!",
    great:  "had a great lipsync!",
    good:   "had a good lipsync.",
    bad:    "had a bad lipsync...",
    bombed: "bombed the lipsync..."
  };

  const tierClass = {
    slayed: "perf-slayed",
    great:  "perf-great",
    good:   "perf-good",
    bad:    "perf-bad",
    bombed: "perf-bombed"
  };

  const tiers = epRes?.lipSync?.tiers || [];

  tiers.forEach(t => {
    const row = document.createElement("div");
    row.className = `queen-row perf-row ${tierClass[t.tier] || ""}`;

    const q = getQueenByNameGuess(t.name);
    const cell = document.createElement("div");
    cell.className = "queen-avatar";

    const img = document.createElement("img");
    img.src = (q && q.imageUrl) || DEFAULT_QUEEN_IMAGE;
    img.alt = t.name;
    cell.appendChild(img);

    row.appendChild(cell);
    wrap.appendChild(row);

    const cap = document.createElement("div");
    cap.className = "perf-caption";
    cap.textContent = `${t.name} ${tierLabel[t.tier] || "had a lip-sync."}`;
    wrap.appendChild(cap);
  });

  card.appendChild(wrap);
}

function renderQueenLinesBlock(lines, card) {
      const clean = (lines || []).filter((l) => l && l.trim());
      clean.forEach((line) => {
        const trimmed = line.trim();
        const names = parseQueenNamesFromLine(trimmed);
        if (names.length) {
          renderQueenRow(names, trimmed, card);
        } else {
          const p = document.createElement("p");
          p.textContent = trimmed;
          card.appendChild(p);
        }
      });
    }

    function renderMiniLines(step, card) {
      const block = document.createElement("div");
      block.className = "results-block";
  
      const heading = document.createElement("div");
      heading.className = "results-heading";
      heading.textContent = "Mini-Challenge";
      block.appendChild(heading);
  
      const challengeRow = document.createElement("div");
      challengeRow.className = "results-row";
      const challengeLabel = document.createElement("strong");
      challengeLabel.textContent = "Challenge:";
      challengeRow.appendChild(challengeLabel);
      challengeRow.appendChild(
        document.createTextNode(" " + (step.miniName || "Mini-Challenge"))
      );
      block.appendChild(challengeRow);

      // Try to find line(s) that describe the winner(s)
      let winnerLine = null;
      for (const line of step.lines || []) {
        const lower = line.trim().toLowerCase();
        if (!lower) continue;
        if (lower.includes("won the mini-challenge") || lower.includes("mini-challenge winner")) {
          winnerLine = line;
          break;
        }
      }

      let winnerNames = [];
      if (winnerLine) {
        winnerNames = parseQueenNamesFromLine(winnerLine);
      }

      if (!winnerNames.length) {
        // Fallback: old style "Mini-challenge winner: Name"
        for (const line of step.lines || []) {
          const trimmed = line.trim();
          const lower = trimmed.toLowerCase();
          if (lower.startsWith("mini-challenge winner:")) {
            const parts = trimmed.split(":");
            if (parts.length > 1) {
              const tail = parts.slice(1).join(":").trim();
              winnerNames = tail.split(/,| and /i).map((p) => p.trim()).filter(Boolean);
            }
            break;
          }
        }
      }

      if (winnerNames.length) {
        renderQueenRow(winnerNames, "won the mini-challenge!", card);
      }

      card.appendChild(block);
    }

    // ✅ FIXED: moved to top-level scope so renderCurrentStep() can call it
    function renderMiniStep(step, card) {
      // Clearer structure:
      // Episode X
      // Mini-Challenge: [Name]!
      // [Winner] won the mini-challenge!
      // They will get an advantage in the maxi-challenge!

      const wrap = document.createElement("div");
      wrap.style.textAlign = "center";
      wrap.style.padding = "0.25rem 0 0.4rem";

      // Episode heading (separate from the mini title)
      const ep = document.createElement("div");
      ep.style.fontWeight = "700";
      ep.style.fontSize = "1.05rem";
      ep.style.marginTop = "0.25rem";
      ep.textContent = `Episode ${step.epNum}`;
      wrap.appendChild(ep);

      // Mini title
      const miniTitle = document.createElement("div");
      miniTitle.style.fontWeight = "800";
      miniTitle.style.fontSize = "1.25rem";
      miniTitle.style.marginTop = "0.25rem";
      miniTitle.style.marginBottom = "0.75rem";
      miniTitle.textContent = `Mini-Challenge: ${(step.miniName || "Mini-Challenge")}!`;
      wrap.appendChild(miniTitle);

      // Determine winner line (same logic you already use)
      let winnerLine = null;
      for (const line of step.lines || []) {
        const lower = line.trim().toLowerCase();
        if (!lower) continue;
        if (lower.includes("won the mini-challenge") || lower.includes("mini-challenge winner")) {
          winnerLine = line;
          break;
        }
      }

      let winnerNames = [];
      if (winnerLine) winnerNames = parseQueenNamesFromLine(winnerLine);

      if (!winnerNames.length) {
        for (const line of step.lines || []) {
          const trimmed = line.trim();
          if (trimmed.toLowerCase().startsWith("mini-challenge winner:")) {
            const tail = trimmed.split(":").slice(1).join(":").trim();
            winnerNames = tail.split(/,| and /i).map(p => p.trim()).filter(Boolean);
            break;
          }
        }
      }

      // Winner avatar row (centered)
      if (winnerNames.length) {
        renderQueenRow(winnerNames, "", wrap);

        const winnerText = document.createElement("div");
        winnerText.style.fontWeight = "700";
        winnerText.style.marginTop = "0.25rem";
        winnerText.textContent = `${formatNameList(winnerNames)} won the mini-challenge!`;
        wrap.appendChild(winnerText);

        const adv = document.createElement("div");
        adv.style.fontSize = "0.9rem";
        adv.style.color = "#ccc";
        adv.style.marginTop = "0.25rem";
        adv.textContent = "They will get an advantage in the maxi-challenge!";
        wrap.appendChild(adv);
      } else {
        const p = document.createElement("div");
        p.style.color = "#ccc";
        p.textContent = "A queen won the mini-challenge!";
        wrap.appendChild(p);
      }

      card.appendChild(wrap);
    }


    function renderMaxiStep(step, card) {
      const wrap = document.createElement("div");
      wrap.className = "maxi-step results-step";

      const title = document.createElement("div");
      title.className = "maxi-title";
      title.textContent = "Maxi-challenge!";
      wrap.appendChild(title);

      // Prefer structured episodeResults from sim.js (future-proof).
      const epIdx = Math.max(0, (step.epNum || 1) - 1);
      const epRes = (seasonEpisodeResults && seasonEpisodeResults[epIdx]) ? seasonEpisodeResults[epIdx] : null;

      // Intro line
      let introLine = "";
      if (epRes && epRes.challengeName) {
        introLine = `Challenge: ${epRes.challengeName}`;
      } else {
        const lines = (step.lines || []).map(l => (l || "").trim()).filter(Boolean);
        // Prefer any explicit narrative line if we have one; otherwise just use the first line.
        for (const ln of lines) {
          const lower = ln.toLowerCase();
          if (
            lower.startsWith("the queens will") ||
            lower.startsWith("the queens are") ||
            lower.startsWith("this week") ||
            lower.startsWith("the queens give") ||
            lower.startsWith("the queens")
          ) {
            introLine = ln;
            break;
          }
        }
        if (!introLine && lines.length) introLine = lines[0];
      }

      const intro = document.createElement("div");
      intro.className = "maxi-intro";
      intro.textContent = introLine || "The queens hit the runway — judging is next.";
      wrap.appendChild(intro);

const buckets = [
        { key: "slayed", label: "slayed the challenge!", rowClass: "perf-slayed" },
        { key: "great",  label: "had a great performance!", rowClass: "perf-great" },
        { key: "good",   label: "had a good performance.", rowClass: "perf-good" },
        { key: "bad",    label: "had a bad performance…", rowClass: "perf-bad" },
        { key: "bombed", label: "bombed the challenge…", rowClass: "perf-bombed" },
      ];

      const grouped = new Map(buckets.map(b => [b.key, []]));

      if (epRes && Array.isArray(epRes.tiers) && epRes.tiers.length) {
        // Use tier thresholds computed by the sim (includes immune queens).
        for (const t of epRes.tiers) {
          if (!t || !t.tier || !t.name) continue;
          const key = String(t.tier).toLowerCase();
          if (!grouped.has(key)) continue;
          grouped.get(key).push(t);
        }
      } else {
        // Back-compat fallback: attempt to infer from narrative lines, if present.
        const lines = (step.lines || []).map(l => (l || "").trim()).filter(Boolean);
        for (const ln of lines) {
          const lower = ln.toLowerCase();
          const names = parseQueenNamesFromLine(ln);
          if (!names.length) continue;
          if (lower.includes("slayed the challenge")) {
            names.forEach(n => grouped.get("slayed").push({ name: n, immune: false }));
          } else if (lower.includes("had a great performance")) {
            names.forEach(n => grouped.get("great").push({ name: n, immune: false }));
          } else if (lower.includes("had a good performance")) {
            names.forEach(n => grouped.get("good").push({ name: n, immune: false }));
          } else if (lower.includes("had a bad performance")) {
            names.forEach(n => grouped.get("bad").push({ name: n, immune: false }));
          } else if (lower.includes("bombed the challenge")) {
            names.forEach(n => grouped.get("bombed").push({ name: n, immune: false }));
          }
        }
      }

      // Render groups (skip empty buckets so slayed/bombed aren't guaranteed visually).
      let renderedAny = false;

      buckets.forEach((b) => {
        const entries = grouped.get(b.key) || [];
        if (!entries.length) return;
        renderedAny = true;

        // Avatar row
        const rowWrap = document.createElement("div");
        rowWrap.className = `queen-row perf-row ${b.rowClass}`;

        entries.forEach((entry) => {
          const raw = (entry && entry.name) ? entry.name : String(entry);
          const q = getQueenByNameGuess(raw);

          const cell = document.createElement("div");
          cell.className = "queen-avatar";

          const img = document.createElement("img");
          img.src = (q && q.imageUrl) || DEFAULT_QUEEN_IMAGE;
          img.alt = q ? q.name : raw;
          cell.appendChild(img);
rowWrap.appendChild(cell);
        });

        wrap.appendChild(rowWrap);

        // Caption under that row
        const cap = document.createElement("div");
        cap.className = "perf-caption";
        const namesForCaption = entries.map(e => (e && e.name) ? e.name : String(e));
        cap.textContent = `${formatNameList(namesForCaption)} ${b.label}`;
        wrap.appendChild(cap);
      });

      if (!renderedAny) {
        const p = document.createElement("div");
        p.style.color = "#ccc";
        p.style.marginTop = "0.5rem";
        p.textContent = "No performance tiers were available for this episode (check that sim.js is returning episodeResults).";
        wrap.appendChild(p);
      }

      card.appendChild(wrap);
    }

    
function getFinaleResult() {
  if (!seasonEpisodeResults || !seasonEpisodeResults.length) return null;
  return seasonEpisodeResults.find(e => e && (e.challengeId === "FINALE" || e.episode === "Finale")) || null;
}


function renderFinal3Step(step, card) {
  const wrap = document.createElement("div");
  wrap.className = "step-section";
  wrap.style.textAlign = "center";

  const title = document.createElement("h2");
  title.textContent = "Final 3 Revealed";
  wrap.appendChild(title);

  // Determine finalist names (prefer parsing the log step, fallback to finale meta).
  let finalists = [];
  const lines = (step && step.lines) ? step.lines : [];
  for (const l of lines) {
    const m = String(l).match(/-\s*([^()]+?)\s*\(track record:/i);
    if (m && m[1]) finalists.push(m[1].trim());
  }

  if (!finalists.length && seasonEpisodeResults && seasonEpisodeResults.length) {
    const finaleRes = seasonEpisodeResults.find(r => r && r.episode === "Finale" && r.finale && Array.isArray(r.finale.finalists));
    if (finaleRes) finalists = finaleRes.finale.finalists.slice(0, 3);
  }

  // Render a "current Top 3 track records" table (main episodes only; no finale column).
  const tableWrap = document.createElement("div");
  tableWrap.style.marginTop = "0.75rem";
  tableWrap.style.textAlign = "left";

  if (trackRecordData && Array.isArray(trackRecordData.episodes) && trackRecordData.episodes.length) {
    const mainEpisodes = trackRecordData.episodes.filter(ep => ep && !ep.isFinale);

    const allowed = new Set(finalists);
    const queenOrder = Array.isArray(trackRecordData.queenOrder)
      ? trackRecordData.queenOrder.filter(q => allowed.size ? allowed.has(q) : true).slice(0, 3)
      : [];

    const sliced = {
      queenOrder,
      episodes: mainEpisodes.map(ep => ({
        ...ep,
        placements: Object.fromEntries(
          queenOrder.map(qn => [qn, (ep.placements && ep.placements[qn]) ? ep.placements[qn] : ""])
        )
      }))
    };

    if (queenOrder.length) {
      renderTrackRecordTable(tableWrap, sliced);
    } else {
      const p = document.createElement("p");
      p.className = "step-note";
      p.textContent = "No finalist track records available.";
      tableWrap.appendChild(p);
    }
  } else {
    const p = document.createElement("p");
    p.className = "step-note";
    p.textContent = "Track record data was not available for this season.";
    tableWrap.appendChild(p);
  }

  wrap.appendChild(tableWrap);

  // Optional: show the raw Final 3 lines under the table.
  if (lines && lines.length) {
    const details = document.createElement("details");
    details.style.marginTop = "0.75rem";
    const summary = document.createElement("summary");
    summary.textContent = "Show Final 3 log";
    details.appendChild(summary);
    const pre = document.createElement("pre");
    pre.textContent = lines.map(l => String(l || "")).join("\n");
    details.appendChild(pre);
    wrap.appendChild(details);
  }

  card.appendChild(wrap);
}

function renderFinaleRunwayStep(step, card) {
  const wrap = document.createElement("div");
  wrap.className = "maxi-step results-step";

  const title = document.createElement("div");
  title.className = "maxi-title";
  title.textContent = "Final Runway!";
  wrap.appendChild(title);

  const intro = document.createElement("div");
  intro.className = "maxi-intro";
  intro.textContent = "The finalists will bring it to the runway!";
  wrap.appendChild(intro);

  const fin = getFinaleResult();
  const cat = fin && fin.runwayCategory ? fin.runwayCategory : "Finale Eleganza Extravaganza";

  const categoryLine = document.createElement("div");
  categoryLine.className = "maxi-intro";
  categoryLine.style.marginTop = "-0.35rem";
  categoryLine.style.fontSize = "0.95rem";
  categoryLine.textContent = `Category is... ${cat}.`;
  wrap.appendChild(categoryLine);

  const buckets = [
    { key: "slayed", label: "slayed the runway!", rowClass: "perf-slayed" },
    { key: "great",  label: "had a great runway!", rowClass: "perf-great" },
    { key: "good",   label: "had a good runway.", rowClass: "perf-good" },
    { key: "bad",    label: "had a bad runway…", rowClass: "perf-bad" },
    { key: "bombed", label: "bombed the runway…", rowClass: "perf-bombed" },
  ];

  const grouped = new Map(buckets.map(b => [b.key, []]));
  const runwayTiers = fin && Array.isArray(fin.runwayTiers) ? fin.runwayTiers : [];

  runwayTiers.forEach(t => {
    const key = String(t.tier || "").toLowerCase();
    if (!grouped.has(key)) return;
    grouped.get(key).push(t);
  });

  let renderedAny = false;
  buckets.forEach(b => {
    const entries = grouped.get(b.key) || [];
    if (!entries.length) return;
    renderedAny = true;

    const rowWrap = document.createElement("div");
    rowWrap.className = `queen-row perf-row ${b.rowClass}`;

    entries.forEach(entry => {
      const raw = entry.name || String(entry);
      const q = getQueenByNameGuess(raw);

      const cell = document.createElement("div");
      cell.className = "queen-avatar";

      const img = document.createElement("img");
      img.src = (q && q.imageUrl) || DEFAULT_QUEEN_IMAGE;
      img.alt = q ? q.name : raw;
      cell.appendChild(img);
      rowWrap.appendChild(cell);
    });

    wrap.appendChild(rowWrap);

    const cap = document.createElement("div");
    cap.className = "perf-caption";
    cap.textContent = `${formatNameList(entries.map(e => e.name || String(e)))} ${b.label}`;
    wrap.appendChild(cap);
  });

  if (!renderedAny) {
    const p = document.createElement("div");
    p.style.color = "#ccc";
    p.style.marginTop = "0.5rem";
    p.textContent = "No runway tiers were available for the Finale (check that sim.js is returning runwayTiers for challengeId FINALE).";
    wrap.appendChild(p);
  }

  card.appendChild(wrap);
}

function renderFinaleTop2RevealStep(step, card) {
  const wrap = document.createElement("div");
  wrap.className = "maxi-step results-step";
  wrap.style.textAlign = "center";

  const title = document.createElement("div");
  title.className = "maxi-title";
  title.textContent = "I've made my decision...";
  wrap.appendChild(title);

  const fin = getFinaleResult();
  const top2 = fin?.finale?.top2 || [];
  const eliminated = fin?.finale?.eliminated || null;

  if (top2.length) {
    renderQueenRow(top2, "", wrap, { neutral: true });

    const p = document.createElement("div");
    p.className = "perf-caption";
    p.textContent = `${formatNameList(top2)}, you will lip-sync for the crown!`;
    wrap.appendChild(p);
  }

  if (eliminated) {
    // A small divider for drama
    const div = document.createElement("div");
    div.className = "judging-divider";
    div.style.margin = "0.75rem auto";
    wrap.appendChild(div);

    renderQueenRow([eliminated], "", wrap, { neutral: true });

    const p2 = document.createElement("div");
    p2.className = "perf-caption";
    p2.textContent = `${eliminated}, you will not advance to the final lip-sync.`;
    wrap.appendChild(p2);
  }

  if (!top2.length && !eliminated) {
    const p = document.createElement("div");
    p.style.color = "#ccc";
    p.textContent = "Finale placement data missing (check sim.js finale output).";
    wrap.appendChild(p);
  }

  card.appendChild(wrap);
}

function renderFinaleLipSyncStep(step, card) {
  const wrap = document.createElement("div");
  wrap.className = "maxi-step results-step";

  const title = document.createElement("div");
  title.className = "maxi-title";
  title.textContent = "Lip Sync for the Crown!";
  wrap.appendChild(title);

  const fin = getFinaleResult();
  const top2 = fin?.finale?.top2 || [];
  const song = fin?.finale?.lipSync?.song || null;
  const tiers = fin?.finale?.lipSync?.tiers || [];

  if (top2.length) {
    renderQueenRow(top2, "", wrap, { neutral: true });
  }

  if (song) {
    const p = document.createElement("div");
    p.className = "maxi-intro";
    p.style.fontWeight = "600";
    p.textContent = `The lip-sync song is... ${song}!`;
    wrap.appendChild(p);
  }

  const tierLabel = {
    slayed: "slayed the lip-sync...",
    great:  "had a great lip-sync...",
    good:   "had a good lip-sync.",
    bad:    "had a bad lip-sync...",
    bombed: "bombed the lip-sync..."
  };

  const tierClass = {
    slayed: "perf-slayed",
    great:  "perf-great",
    good:   "perf-good",
    bad:    "perf-bad",
    bombed: "perf-bombed"
  };

  (tiers || []).forEach(t => {
    if (!t || !t.name) return;

    const row = document.createElement("div");
    row.className = `queen-row perf-row ${tierClass[t.tier] || ""}`;

    const q = getQueenByNameGuess(t.name);
    const cell = document.createElement("div");
    cell.className = "queen-avatar";

    const img = document.createElement("img");
    img.src = (q && q.imageUrl) || DEFAULT_QUEEN_IMAGE;
    img.alt = t.name;
    cell.appendChild(img);

    row.appendChild(cell);
    wrap.appendChild(row);

    const cap = document.createElement("div");
    cap.className = "perf-caption";
    cap.textContent = `${t.name} ${tierLabel[t.tier] || "had a lip-sync."}`;
    wrap.appendChild(cap);
  });

  card.appendChild(wrap);
}

function renderFinaleWinnerStep(step, card) {
  const wrap = document.createElement("div");
  wrap.className = "maxi-step results-step";
  wrap.style.textAlign = "center";

  const title = document.createElement("div");
  title.className = "maxi-title";
  title.textContent = "The end...";
  wrap.appendChild(title);

  const fin = getFinaleResult();
  const winner = fin?.finale?.winner || null;

  if (winner) {
    renderQueenRow([winner], "", wrap, { neutral: true });

    const p = document.createElement("div");
    p.className = "perf-caption";
    p.style.fontSize = "1.05rem";
    p.style.fontWeight = "800";
    p.textContent = `And the winner of this season is... ${winner}!! 👑`;
    wrap.appendChild(p);
  }

  // Optional: include the full track records table toggle (same as season output)
  if (typeof renderTrackRecordTable === "function") {
    const spacer = document.createElement("div");
    spacer.style.height = "0.75rem";
    wrap.appendChild(spacer);

    const details = document.createElement("details");
    details.className = "episode-card";
    details.style.marginTop = "0.75rem";
    details.style.background = "#141414";

    const summary = document.createElement("summary");
    summary.style.cursor = "pointer";
    summary.style.fontWeight = "700";
    summary.style.color = "#ff80ab";
    summary.textContent = "Show full track records";
    details.appendChild(summary);

    const holder = document.createElement("div");
    holder.style.marginTop = "0.75rem";
    details.appendChild(holder);

    // renderTrackRecordTable writes into a container
    renderTrackRecordTable(holder,
        (typeof trackRecordData !== "undefined" && trackRecordData && Array.isArray(trackRecordData.episodes)) ? trackRecordData :
        (typeof buildTrackRecordFromLog === "function" ? (buildTrackRecordFromLog(lastSeasonLog) || null) : null)
      );
wrap.appendChild(details);
  }

  card.appendChild(wrap);
}


function renderFinaleLines(lines, card) {
      const block = document.createElement("div");
      block.className = "results-block";

      let titlePrinted = false;
      let skippingLipScores = false;

      for (const line of lines) {
        const trimmed = line.trim();
        if (!trimmed) continue;

        if (trimmed.startsWith("========== Grand Finale")) {
          const h = document.createElement("div");
          h.className = "results-heading";
          h.textContent = "Grand Finale";
          block.appendChild(h);
          titlePrinted = true;
          continue;
        }

        // Skip numeric lip-sync breakdowns, keep the flavour text
        if (/^Final lip sync performance:/i.test(trimmed)) {
          skippingLipScores = true;
          continue;
        }
        if (skippingLipScores) {
          if (/devours the stage/i.test(trimmed) || /^And the winner/i.test(trimmed)) {
            skippingLipScores = false;
            // fall through and render this line
          } else {
            continue;
          }
        }

        const p = document.createElement("div");
        p.className = "results-row";
        p.textContent = trimmed;
        block.appendChild(p);
      }

      if (!titlePrinted) {
        const h = document.createElement("div");
        h.className = "results-heading";
        h.textContent = "Grand Finale";
        block.insertBefore(h, block.firstChild);
      }

      card.appendChild(block);

      const trackContainer = document.createElement("div");
      trackContainer.style.marginTop = "1rem";

      const toggleWrap = document.createElement("div");
      toggleWrap.className = "track-record-toggle";
      const toggleLabel = document.createElement("label");
      const toggleCheckbox = document.createElement("input");
      toggleCheckbox.type = "checkbox";
      toggleCheckbox.checked = false;
      toggleLabel.appendChild(toggleCheckbox);
      toggleLabel.appendChild(
        document.createTextNode(" Show full track records")
      );
      toggleWrap.appendChild(toggleLabel);
      trackContainer.appendChild(toggleWrap);

      const tableWrapper = document.createElement("div");
      tableWrapper.className = "track-record-table-wrapper";
      tableWrapper.style.display = "none";
      trackContainer.appendChild(tableWrapper);

      toggleCheckbox.addEventListener("change", () => {
        tableWrapper.style.display = toggleCheckbox.checked ? "block" : "none";
      });

      card.appendChild(trackContainer);

      if (trackRecordData && Array.isArray(trackRecordData.episodes)) {
        renderTrackRecordTable(tableWrapper, trackRecordData);
      } else {
        const fallback = buildTrackRecordFromLog(lastSeasonLog);
        if (fallback) {
          renderTrackRecordTable(tableWrapper, fallback);
        } else {
          const p = document.createElement("p");
          p.textContent =
            "Track record data was not available for this season.";
          p.style.fontSize = "0.8rem";
          p.style.color = "#aaa";
          tableWrapper.appendChild(p);
        }
      }
    }

    function renderSeasonFull(log) {
      currentSteps = buildStepsFromLog(log);
      currentStepIndex = 0;
      renderCurrentStep();
    }

    function renderSeasonSummary(log) {
      const { header, episodes, finale } = parseSeasonLog(log);
      // Keep a canonical count of competitive episodes for the track record
      seasonEpisodeCount = episodes.length;
    
      const summaryEl = document.createElement("div");

      const headerLines = filterHeader(header);

      // Header / season info – only if we actually have anything to show
      if (headerLines.length) {
        const headerCard = document.createElement("details");
        headerCard.className = "episode-card";
        headerCard.open = false;

        const headerSummary = document.createElement("summary");
        headerSummary.textContent = "Season overview";
        headerCard.appendChild(headerSummary);

        const pre = document.createElement("pre");
        pre.textContent = headerLines.join("\n");
        headerCard.appendChild(pre);

        summaryEl.appendChild(headerCard);
      }

      // Episodes
      episodes.forEach((ep, index) => {
        const epCard = document.createElement("details");
        epCard.className = "episode-card";
        epCard.open = false;

        const titleLine = ep.lines.find((l) =>
          l.startsWith("========== Episode")
        );
        const m = titleLine
          ? titleLine.match(/Episode (\d+) — (.+?) =+/)
          : null;
        const epNum = m ? parseInt(m[1], 10) : index + 1;
        const epName = m ? m[2] : "Unknown challenge";

        const summary = document.createElement("summary");
        summary.textContent = `Episode ${epNum}: ${epName}`;
        epCard.appendChild(summary);

        const bodyPre = document.createElement("pre");
        bodyPre.textContent = filterEpisode(ep.lines).join("\n");
        epCard.appendChild(bodyPre);

        summaryEl.appendChild(epCard);
      });

      // Finale / track record
      if (finale.length) {
        const finaleCard = document.createElement("details");
        finaleCard.className = "episode-card summary-final finale-card";
        finaleCard.open = false; // collapsed by default now

        const summary = document.createElement("summary");
        summary.textContent = "Grand Finale & track records";
        finaleCard.appendChild(summary);

        const bodyPre = document.createElement("pre");
        // Reuse the same Finale filtering we use in full view so raw stats don't show
        const filteredLines = [];
        let skippingLip = false;
        for (const line of finale) {
          const trimmed = line.trim();
          if (!trimmed) continue;
          if (trimmed.startsWith("Final lip sync performance:")) {
            skippingLip = true;
            continue;
          }
          if (skippingLip) {
            if (/devours the stage/i.test(trimmed) || /^And the winner/i.test(trimmed)) {
              skippingLip = false;
            } else {
              continue;
            }
          }
          filteredLines.push(line);
        }
        bodyPre.textContent = filteredLines.join("\n");
        finaleCard.appendChild(bodyPre);

        const trackContainer = document.createElement("div");
        trackContainer.style.marginTop = "1rem";

        const toggleWrap = document.createElement("div");
        toggleWrap.className = "track-record-toggle";
        const toggleLabel = document.createElement("label");
        const toggleCheckbox = document.createElement("input");
        toggleCheckbox.type = "checkbox";
        toggleCheckbox.checked = false;
        toggleLabel.appendChild(toggleCheckbox);
        toggleLabel.appendChild(
          document.createTextNode(" Show full track records")
        );
        toggleWrap.appendChild(toggleLabel);
        trackContainer.appendChild(toggleWrap);

        const tableWrapper = document.createElement("div");
        tableWrapper.className = "track-record-table-wrapper";
        tableWrapper.style.display = "none";
        trackContainer.appendChild(tableWrapper);

        toggleCheckbox.addEventListener("change", () => {
          tableWrapper.style.display = toggleCheckbox.checked ? "block" : "none";
        });

        finaleCard.appendChild(trackContainer);

        if (trackRecordData && Array.isArray(trackRecordData.episodes)) {
          renderTrackRecordTable(tableWrapper, trackRecordData);
        } else {
          const fallback = buildTrackRecordFromLog(lastSeasonLog);
          if (fallback) {
            renderTrackRecordTable(tableWrapper, fallback);
          } else {
            const p = document.createElement("p");
            p.textContent =
              "Track record data was not available for this season.";
            p.style.fontSize = "0.8rem";
            p.style.color = "#aaa";
            tableWrapper.appendChild(p);
          }
        }

        summaryEl.appendChild(finaleCard);
      }

      seasonContainer.innerHTML = "";
      seasonContainer.appendChild(summaryEl);
    }

    function buildTrackRecordFromLog(logText) {
      const lines = (logText || "").split(/\r?\n/);
      const queenNames = new Set();
      const episodes = [];

      let currentEpisode = null;
      let epIdx = 0;

      function finalizeEpisode() {
        if (!currentEpisode) return;
        episodes.push(currentEpisode);
        currentEpisode = null;
      }

      for (const line of lines) {
        const trimmed = line.trim();

        if (trimmed.startsWith("========== Episode")) {
          finalizeEpisode();
          currentEpisode = {
            index: epIdx++,
            placements: {},
          };
          continue;
        }

        if (!currentEpisode) continue;

        if (trimmed.startsWith("Results:")) {
          continue;
        }

        const patterns = [
          { key: "WIN", label: "Winner:" },
          { key: "HIGH", label: "High:" },
          { key: "LOW", label: "Low:" },
          { key: "BTM", label: "Bottom:" },
          { key: "SAFE", label: "Safe:" },
          { key: "ELIM", label: "Sashay away:" },
          { key: "RTRN", label: "Returned:" },
        ];

        for (const ptn of patterns) {
          if (trimmed.startsWith(ptn.label)) {
            const list = trimmed
              .slice(ptn.label.length)
              .split(",")
              .map((s) => s.trim())
              .filter(Boolean);
            list.forEach((name) => {
              queenNames.add(name);
              currentEpisode.placements[name] = ptn.key;
            });
          }
        }
      }

      finalizeEpisode();

      if (!episodes.length || !queenNames.size) return null;

      const queenOrder = Array.from(queenNames);
      const episodeCount = episodes.length;

      const tableEpisodes = [];
      for (let i = 0; i < episodeCount; i++) {
        const ep = episodes[i] || { placements: {} };
        const placement = {};
        queenOrder.forEach((q) => {
          placement[q] = ep.placements[q] || "";
        });

        const isFinale = i === episodeCount - 1;
        tableEpisodes.push({
          index: i,
          isFinale,
          name: isFinale ? "Finale" : "Episode " + (i + 1),
          placements: placement,
        });
      }

      return {
        queenOrder,
        episodes: tableEpisodes,
      };
    }
    
    function renderTrackRecordTable(container, data) {
      container.innerHTML = "";
      if (!data || !Array.isArray(data.episodes) || !data.episodes.length) {
        const p = document.createElement("p");
        p.textContent = "No track record data available.";
        p.style.fontSize = "0.8rem";
        p.style.color = "#aaa";
        container.appendChild(p);
        return;
      }

      // Work on a copy so we don't mutate the original meta.
      const episodesArr = data.episodes.slice();

      // IMPORTANT:
      // Only treat a column as the Finale column if the data explicitly marks it (ep.isFinale === true).
      // This prevents "Final 3 Revealed" tables (which are main-episode only) from auto-spoiling.
      const hasFinale = episodesArr.some(ep => ep && ep.isFinale);

      const mainEpisodes = hasFinale ? episodesArr.filter(ep => ep && !ep.isFinale) : episodesArr;
      const finaleEpisode = hasFinale ? episodesArr.find(ep => ep && ep.isFinale) : null;
      const allEpisodes = hasFinale && finaleEpisode ? [...mainEpisodes, finaleEpisode] : mainEpisodes;

      const table = document.createElement("table");
      table.className = "track-record-table";

      // ---------- Header ----------
      const thead = document.createElement("thead");
      const headRow = document.createElement("tr");

      const thName = document.createElement("th");
      thName.textContent = "Queen";
      thName.className = "track-name";
      headRow.appendChild(thName);

      allEpisodes.forEach((ep, idx) => {
        const th = document.createElement("th");
        const isFinale = !!(ep && ep.isFinale);
        th.textContent = (ep && ep.name) ? ep.name : (isFinale ? "Finale" : "Episode " + (idx + 1));
        headRow.appendChild(th);
      });

      thead.appendChild(headRow);
      table.appendChild(thead);

      // ---------- Body ----------
      const tbody = document.createElement("tbody");

      data.queenOrder.forEach((qName, rowIndex) => {
        const row = document.createElement("tr");

        const nameCell = document.createElement("td");
        nameCell.textContent = qName;
        nameCell.className = "track-name";
        row.appendChild(nameCell);

        allEpisodes.forEach((ep, colIndex) => {
          const cell = document.createElement("td");
          const isFinale = !!(ep && ep.isFinale);

          if (isFinale) {
            // Finale column: prefer explicit finale placements if present,
            // otherwise fall back to the (winner, runners-up) display order.
            const raw = ep && ep.placements && Object.prototype.hasOwnProperty.call(ep.placements, qName)
              ? ep.placements[qName]
              : "";

            let status = "";
            if (raw && typeof raw === "object") status = raw.status || "";
            else status = raw || "";

            // If status isn't provided, use row order for Top 3 display
            if (!status) {
              if (rowIndex === 0) status = "WIN";
              else if (rowIndex === 1 || rowIndex === 2) status = "RUN-UP";
            }

            let cls = "status-empty";
            if (status === "WIN") cls = "status-final-win";
            else if (status === "RUN-UP") cls = (rowIndex === 1 ? "status-final-runner1" : "status-final-runner2");

            cell.textContent = status || "";
            cell.className = cls;
            row.appendChild(cell);
            return;
          }

          // Normal competitive episode cell
          const rawPlacement =
            ep &&
            ep.placements &&
            Object.prototype.hasOwnProperty.call(ep.placements, qName)
              ? ep.placements[qName]
              : "";

          let status = "";
          let immune = false;

          if (rawPlacement && typeof rawPlacement === "object") {
            status = rawPlacement.status || "";
            immune = !!rawPlacement.immune;
          } else {
            status = rawPlacement || "";
          }

          const displayStatus = status === "RTRN" ? "RTRN" : status;
          cell.innerHTML = displayStatus + (immune ? '<br><small>(IMM)</small>' : "");

          if (!status) {
            cell.className = "status-empty";
          } else {
            switch (status) {
              case "WIN":
                cell.className = "status-win";
                break;
              case "HIGH":
                cell.className = "status-high";
                break;
              case "SAFE":
                cell.className = "status-safe";
                break;
              case "LOW":
                cell.className = "status-low";
                break;
              case "BTM":
                cell.className = "status-bottom";
                break;
              case "ELIM":
                cell.className = "status-elim";
                break;
              case "RTRN":
                cell.className = "status-rtu";
                break;
              default:
                cell.className = "status-empty";
            }
          }

          row.appendChild(cell);
        });

        tbody.appendChild(row);
      });

      table.appendChild(tbody);
      container.appendChild(table);
    }

    function getNextLabel(step, index, total) {
      if (index === total - 1) return "Back to start";
      switch (step.type) {
        case "cast":
          return "Start Episode 1";
        case "episode_setup":
          return "Mini-challenge";
        case "episode_mini":
          return "Maxi-challenge";
        case "episode_maxi":
          // If a runway step exists next, go there first.
          if (currentSteps[index + 1] && currentSteps[index + 1].type === "episode_runway") return "Runway";
          return "Judging";
        case "episode_runway":
          return "Judging";
        case "episode_judging":
          return "Bring back my girls";
        case "episode_bring_back":
          return "Lipsync";
        case "episode_lipsync":
          return "Results";
        case "episode_results":
          return "Next episode";
        case "final3":
          return "Final Runway";
        case "finale_runway":
          return "Top 2";
        case "finale_top2_reveal":
          return "Lip Sync";
        case "finale_lipsync":
          return "Winner";
        case "finale_winner":
          return "Back to start";
        default:
          return "Next";
      }
    }

    function renderCurrentStep() {
      seasonContainer.innerHTML = "";
      if (!currentSteps.length) {
        seasonContainer.textContent = "No steps available.";
        return;
      }
      const step = currentSteps[currentStepIndex];

      const card = document.createElement("div");
      card.className = "episode-card step-" + step.type;

      let titleText = "";
      let bodyLines = [];

      switch (step.type) {
        case "cast":
          titleText = "Cast Reveal";
          bodyLines = step.lines || [];
          break;
        case "episode_setup":
          titleText = `Episode ${step.epNum} — ${step.name}`;
          bodyLines = [
            `In Episode ${step.epNum}, the queens face the ${step.name}.`,
            "",
            "Proceed to see how they perform.",
          ];
          break;
        case "episode_mini":
          titleText = ""; // we'll render our own headings inside renderMiniStep
          bodyLines = step.lines || [];
          break;
        case "episode_maxi":
          titleText = ""; // rendered inside renderMaxiStep
          bodyLines = step.lines || [];
          break;
        case "episode_judging":
          titleText = `Episode ${step.epNum} — Judging`;
          bodyLines = step.lines || [];
          break;
        case "episode_bring_back":
          titleText = `Episode ${step.epNum} — Bring back my girls!`;
          bodyLines = step.lines || [];
          break;
        case "episode_lipsync":
          titleText = `Episode ${step.epNum} — The time has come…`;
          bodyLines = step.lines || [];
          break;
        case "episode_results":
          titleText = `Episode ${step.epNum} — Results`;
          bodyLines = step.lines || [];
          break;
        case "final3":
          titleText = "Final 3 Revealed";
          bodyLines = step.lines || [];
          break;
        case "finale_runway":
          titleText = "";
          bodyLines = [];
          break;
        case "finale_top2_reveal":
          titleText = "";
          bodyLines = [];
          break;
        case "finale_lipsync":
          titleText = "";
          bodyLines = [];
          break;
        case "finale_winner":
          titleText = "";
          bodyLines = [];
          break;
        default:
          titleText = "Season";
          bodyLines = step.lines || [];
      }

      if (titleText) {
        const h = document.createElement("h3");
        h.textContent = titleText;
        card.appendChild(h);
      }
if (step.type === "episode_setup") {
  const p = document.createElement("p");
  p.textContent = bodyLines.join("\n");
  card.appendChild(p);

} else if (step.type === "episode_mini") {
  renderMiniStep(step, card);

} else if (step.type === "episode_maxi") {
  renderMaxiStep(step, card);

} else if (step.type === "episode_runway") {
  renderRunwayStep(step, card);

} else if (step.type === "episode_judging") {
  renderJudgingStep(step, card);

} else if (step.type === "episode_bring_back") {
  renderBringBackStep(step, card);

} else if (step.type === "episode_lipsync") {
  renderLipSyncStep(step, card);

} else if (step.type === "episode_results") {
  renderResultsStep(step, card);

} else if (step.type === "final3") {
  renderFinal3Step(step, card);

} else if (step.type === "finale_runway") {
  renderFinaleRunwayStep(step, card);

} else if (step.type === "finale_top2_reveal") {
  renderFinaleTop2RevealStep(step, card);

} else if (step.type === "finale_lipsync") {
  renderFinaleLipSyncStep(step, card);

} else if (step.type === "finale_winner") {
  renderFinaleWinnerStep(step, card);

} else {
  const pre = document.createElement("pre");
  pre.textContent = bodyLines.join("\n");
  card.appendChild(pre);
}

      const nav = document.createElement("div");
      nav.className = "step-nav";

      const backBtn = document.createElement("button");
      backBtn.textContent = "Back";
      backBtn.disabled = currentStepIndex === 0;
      backBtn.addEventListener("click", () => {
        if (currentStepIndex > 0) {
          currentStepIndex--;
          renderCurrentStep();
        }
      });

      const nextBtn = document.createElement("button");
      nextBtn.textContent = getNextLabel(
        step,
        currentStepIndex,
        currentSteps.length
      );
      nextBtn.addEventListener("click", () => {
        if (currentStepIndex === currentSteps.length - 1) {
          currentStepIndex = 0;
        } else {
          currentStepIndex++;
        }
        renderCurrentStep();
      });

      nav.appendChild(backBtn);
      nav.appendChild(nextBtn);
      card.appendChild(nav);

      if (currentViewMode === "full") {
  const exitRow = document.createElement("div");
  exitRow.className = "step-exit";

  const backSetupBtn = document.createElement("button");
  backSetupBtn.textContent = "Back to cast builder";
  backSetupBtn.addEventListener("click", goBackToSetup);

  exitRow.appendChild(backSetupBtn);
  card.appendChild(exitRow);
}

      seasonContainer.appendChild(card);

      // Always jump the viewport to the card so it feels like a "new page"
      window.scrollTo({ top: 0, behavior: "smooth" });
    }

    // =========================
    // Initial data load
    // =========================

    function renderCustomQueenSelect() {
      // Deprecated in this refactor; kept as a no-op placeholder
    }

    document.addEventListener("DOMContentLoaded", () => {
      // Fallbacks for different queens.js exports.
      let sourceDefault = [];

      if (Array.isArray(window.DEFAULT_QUEENS)) {
        sourceDefault = window.DEFAULT_QUEENS;
      } else if (typeof DEFAULT_QUEENS !== "undefined" && Array.isArray(DEFAULT_QUEENS)) {
        sourceDefault = DEFAULT_QUEENS;
      } else if (Array.isArray(window.QUEENS)) {
        // Older queens.js used window.QUEENS
        sourceDefault = window.QUEENS;
      } else {
        console.warn("DEFAULT_QUEENS is not defined or not an array.");
        sourceDefault = [];
      }

      defaultQueens = sourceDefault.map(q => ({
        ...q,
        imageUrl: (q.imageUrl && q.imageUrl.trim()) ? q.imageUrl.trim() : DEFAULT_QUEEN_IMAGE
      }));
      customQueens = loadCustomQueens().map(q => ({
        ...q,
        imageUrl: (q.imageUrl && q.imageUrl.trim()) ? q.imageUrl.trim() : DEFAULT_QUEEN_IMAGE
      }));
      allQueens = [...defaultQueens, ...customQueens];
      rebuildQueenNameMap();

      syncCastSizeLabel();
      updateCastCount();
      initEditFlagCheckboxes();
      renderCustomQueenSelect();
      renderCastList();
      renderSearchResults("");
    });
  </script>
</body>
</html>
