<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Drag Race Season Simulator</title>
  <link rel="stylesheet" href="style.css" />

  <!-- Card / collapsible styling -->
  <style>
    body {
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      background: #111;
      color: #eee;
      margin: 0;
    }

    .app {
      max-width: 960px;
      margin: 0 auto;
      padding: 1.5rem;
    }

    h1, h2 {
      text-align: center;
      margin-top: 0;
    }

    .controls {
      background: #1b1b1b;
      padding: 1rem;
      border-radius: 8px;
      margin-bottom: 1.5rem;
      box-shadow: 0 0 0 1px #222;
    }

    .control-row {
      margin-bottom: 0.75rem;
      display: flex;
      align-items: center;
      gap: 0.5rem;
      flex-wrap: wrap;
    }

    textarea {
      width: 100%;
      font-family: monospace;
      font-size: 0.85rem;
      background: #000;
      color: #eee;
      border-radius: 4px;
      border: 1px solid #444;
      padding: 0.5rem;
      resize: vertical;
    }

    select {
      background: #000;
      color: #eee;
      border-radius: 4px;
      border: 1px solid #444;
      padding: 0.2rem 0.4rem;
    }

    input[type="number"],
    input[type="text"],
    input[type="url"],
    input[type="range"] {
      background: #000;
      color: #eee;
      border-radius: 4px;
      border: 1px solid #444;
      padding: 0.25rem 0.4rem;
      font-size: 0.85rem;
    }

    button {
      padding: 0.4rem 0.8rem;
      border-radius: 4px;
      border: none;
      cursor: pointer;
      background: #e91e63;
      color: #fff;
      font-weight: 600;
    }

    button:hover:not(:disabled) {
      filter: brightness(1.1);
    }

    button:disabled {
      opacity: 0.4;
      cursor: default;
    }

    .muted {
      font-size: 0.8rem;
      opacity: 0.8;
    }

    /* Episode / step cards */
    .episode-card {
      background: #161616;
      border-radius: 8px;
      padding: 0.75rem 1rem;
      margin-bottom: 0.75rem;
      box-shadow: 0 0 0 1px #222;
      border-left: 3px solid #444;
    }

    .header-card {
      border-left-color: #e91e63;
    }

    .finale-card {
      border-left-color: #ffc107;
    }

    details.episode-card > summary {
      cursor: pointer;
      font-weight: 600;
      list-style: none;
    }

    details.episode-card > summary::-webkit-details-marker {
      display: none;
    }

    details.episode-card > summary::before {
      content: "â–¶";
      display: inline-block;
      margin-right: 0.4rem;
      font-size: 0.8rem;
    }

    details.episode-card[open] > summary::before {
      content: "â–¼";
    }

    .episode-card pre {
      white-space: pre-wrap;
      font-size: 0.8rem;
      margin: 0.5rem 0 0;
      font-family: Menlo, Consolas, monospace;
    }

    /* Full-view step styling */
    .step-cast {
      border-left-color: #e91e63;
    }

    .step-episode_setup {
      border-left-color: #9c27b0;
    }

    .step-episode_mini {
      border-left-color: #4caf50;
    }

    .step-episode_results {
      border-left-color: #ff9800;
    }

    .step-final3 {
      border-left-color: #03a9f4;
    }

    .step-finale {
      border-left-color: #ffc107;
      box-shadow: 0 0 12px rgba(255, 215, 0, 0.2);
    }

    .step-meta {
      font-size: 0.8rem;
      opacity: 0.8;
      margin-bottom: 0.25rem;
    }

    .episode-card h3 {
      margin: 0.25rem 0 0.5rem;
      text-align: left;
    }

    .episode-card p {
      margin: 0.5rem 0 0;
      font-size: 0.9rem;
      line-height: 1.4;
    }

    .results-block {
      margin-top: 0.5rem;
      font-size: 0.9rem;
    }

    .results-heading {
      font-weight: 700;
      margin-bottom: 0.3rem;
      text-transform: uppercase;
      letter-spacing: 0.05em;
      font-size: 0.8rem;
      opacity: 0.85;
    }

    .results-row {
      margin: 0.15rem 0;
    }

    .results-row strong {
      margin-right: 0.35rem;
    }

    .step-nav {
      margin-top: 0.75rem;
      display: flex;
      justify-content: space-between;
      gap: 0.5rem;
    }

    /* Track record table styling */
    .track-record-table {
      width: 100%;
      border-collapse: collapse;
      margin-top: 0.75rem;
      font-size: 0.8rem;
    }

    .track-record-table th,
    .track-record-table td {
      border: 1px solid #333;
      padding: 0.25rem 0.35rem;
      text-align: center;
    }

    .track-record-table th {
      background: #222;
      font-weight: 600;
    }

    .track-record-table .track-name {
      text-align: left;
      white-space: nowrap;
      background: #202020;
      position: sticky;
      left: 0;
      z-index: 1;
    }

    .track-record-table .status-empty {
      background: #181818;
    }

    .track-record-table .status-win {
      background: #3f51b5;
      color: #fff;
      font-weight: 700;
    }

    .track-record-table .status-high {
      background: #8bc6ff;
      color: #000;
    }

    .track-record-table .status-safe {
      background: #d0d0d0;
      color: #000;
    }

    .track-record-table .status-low {
      background: #ffccdf;
      color: #000;
    }

    .track-record-table .status-btm {
      background: #ff7043;
      color: #000;
      font-weight: 700;
    }

    .track-record-table .status-elim {
      background: #424242;
      color: #fff;
      font-weight: 700;
    }

    .track-record-table .status-finale-winner {
      background: #ffd54f; /* gold */
      color: #000;
      font-weight: 700;
    }

    .track-record-table .status-finale-runner {
      background: #cfd8dc; /* silver */
      color: #000;
      font-weight: 600;
    }

    .track-record-table .status-finale-runner-bronze {
      background: #ffb74d; /* bronze */
      color: #000;
      font-weight: 600;
    }

    /* Immunity tag styling */
    .track-record-table .status-immunity-tag {
      font-size: 0.65rem;
      opacity: 0.8;
      margin-top: 0.1rem;
      letter-spacing: 0.05em;
    }

    /* ---- Cast builder / custom queen UI ---- */
    .cast-builder-layout {
      display: flex;
      flex-direction: column;
      gap: 1rem;
    }

    @media (min-width: 800px) {
      .cast-builder-layout {
        flex-direction: row;
      }
    }

    .cast-column {
      flex: 2;
    }

    .custom-column {
      flex: 1.6;
    }

    .queen-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(120px, 1fr));
      gap: 0.75rem;
      margin-top: 0.75rem;
      max-height: 480px;
      overflow-y: auto;
    }

    .queen-card {
      background: #171717;
      border-radius: 10px;
      padding: 0.5rem;
      text-align: center;
      box-shadow: 0 0 0 1px #262626;
      cursor: pointer;
      transition: transform 0.1s ease, box-shadow 0.1s ease, background 0.1s ease;
      position: relative;
    }

    .queen-card img {
      width: 64px;
      height: 64px;
      border-radius: 50%;
      object-fit: cover;
      display: block;
      margin: 0 auto 0.35rem;
      box-shadow: 0 0 0 2px #000;
    }

    .queen-name {
      font-size: 0.82rem;
      font-weight: 600;
    }

    .queen-card .custom-badge {
      position: absolute;
      top: 4px;
      right: 6px;
      font-size: 0.6rem;
      background: #ff9800;
      color: #000;
      padding: 0.1rem 0.25rem;
      border-radius: 999px;
      font-weight: 700;
      letter-spacing: 0.03em;
      text-transform: uppercase;
    }

    .queen-card.selected {
      background: #e91e63;
      box-shadow: 0 0 0 2px #ff4081;
      transform: translateY(-1px);
    }

    .queen-card.selected .queen-name {
      color: #fff;
    }

    .cast-builder-header {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      flex-wrap: wrap;
      justify-content: space-between;
    }

    .cast-size-wrapper {
      display: flex;
      align-items: center;
      gap: 0.4rem;
      flex-wrap: wrap;
    }

    .cast-builder-buttons {
      display: flex;
      gap: 0.4rem;
      flex-wrap: wrap;
    }

    .custom-form {
      display: flex;
      flex-direction: column;
      gap: 0.35rem;
    }

    .custom-form label {
      font-size: 0.8rem;
    }

    .stat-grid {
      display: grid;
      grid-template-columns: 1fr 0.7fr;
      gap: 0.25rem 0.5rem;
      align-items: center;
    }

    .custom-actions {
      display: flex;
      gap: 0.4rem;
      flex-wrap: wrap;
      margin-top: 0.25rem;
    }

    .custom-select-row {
      display: flex;
      align-items: center;
      gap: 0.4rem;
      margin-top: 0.5rem;
      flex-wrap: wrap;
      justify-content: space-between;
    }

    .custom-preview {
      text-align: center;
      margin-top: 0.5rem;
    }

    .custom-preview img {
      width: 72px;
      height: 72px;
      border-radius: 50%;
      object-fit: cover;
      box-shadow: 0 0 0 2px #000;
      display: block;
      margin: 0 auto;
    }

    .chip {
      display: inline-flex;
      align-items: center;
      padding: 0.15rem 0.4rem;
      border-radius: 999px;
      background: #222;
      font-size: 0.7rem;
      text-transform: uppercase;
      letter-spacing: 0.04em;
      opacity: 0.85;
    }
  </style>
</head>
<body>
  <main class="app">
    <h1>Drag Race Season Simulator</h1>

    <!-- Top-level run options -->
    <section class="controls">
      <div class="control-row">
        <label>
          Mode:
          <select id="modeSelect">
            <option value="normal">Normal</option>
            <option value="chaos">Chaos</option>
          </select>
        </label>

        <label>
          View:
          <select id="viewSelect">
            <option value="summary">Summary</option>
            <option value="full">Full</option>
          </select>
        </label>

        <label>
          <input type="checkbox" id="immunityToggle" checked />
          Immunity (early episodes)
        </label>

        <label>
          <input type="checkbox" id="doubleTwistsToggle" checked />
          Double shantays/sashays
        </label>
      </div>

      <div class="control-row">
        <span class="muted">
          Build a cast using the GUI below, or paste / edit raw JSON in the
          advanced box. If a GUI cast is selected, it will be used instead of the JSON.
        </span>
      </div>

      <div class="control-row" style="width:100%;">
        <label style="width:100%;">
          Advanced â€” Queens JSON:
          <textarea id="queensInput" rows="8" spellcheck="false"></textarea>
        </label>
      </div>

      <div class="control-row">
        <button id="loadDefaultQueens">Load sample cast</button>
        <button id="simulateButton">Simulate Season</button>
      </div>
    </section>

    <!-- Cast builder + custom queens -->
    <section class="controls">
      <h2>Cast Builder & Custom Queens</h2>

      <div class="cast-builder-layout">
        <!-- Left: cast picker -->
        <div class="cast-column">
          <div class="cast-builder-header">
            <div class="cast-size-wrapper">
              <label for="castSizeRange">Cast size:</label>
              <input id="castSizeRange" type="range" min="4" max="20" value="12" />
              <span id="castSizeLabel" class="chip">12 queens</span>
            </div>
            <div class="cast-builder-buttons">
              <button id="btnRandomAll">Random</button>
              <button id="btnRandomCustoms">Random customs</button>
              <button id="btnClearCast">Clear cast</button>
            </div>
          </div>

          <div class="muted" style="margin-top:0.4rem;">
            Click queens to add/remove them from the cast. Selected queens are highlighted.
          </div>

          <div id="queenGrid" class="queen-grid"></div>
        </div>

        <!-- Right: custom queen editor -->
        <div class="custom-column">
          <h3>Create or edit a custom queen</h3>
          <form id="customQueenForm" class="custom-form" onsubmit="return false;">
            <label>
              Name:
              <input id="customName" type="text" placeholder="Queen nameâ€¦" />
            </label>

            <button type="button" id="btnRandomizeStats">Randomize stats</button>
            <span class="muted">(Stats should range from 0 to 10)</span>

            <div class="stat-grid">
              <label for="statActing">Acting:</label>
              <input id="statActing" type="number" min="0" max="10" />
              <label for="statComedy">Comedy:</label>
              <input id="statComedy" type="number" min="0" max="10" />
              <label for="statDance">Dance:</label>
              <input id="statDance" type="number" min="0" max="10" />
              <label for="statDesign">Design:</label>
              <input id="statDesign" type="number" min="0" max="10" />
              <label for="statImprov">Improv:</label>
              <input id="statImprov" type="number" min="0" max="10" />
              <label for="statRunway">Runway:</label>
              <input id="statRunway" type="number" min="0" max="10" />
              <label for="statSinging">Singing:</label>
              <input id="statSinging" type="number" min="0" max="10" />
              <label for="statLipsync">Lip Sync:</label>
              <input id="statLipsync" type="number" min="0" max="10" />
            </div>

            <label>
              Image URL:
              <input id="customImageUrl" type="url" placeholder="https://example.com/image.png" />
            </label>

            <div class="custom-actions">
              <button type="button" id="btnAddQueen">Add queen</button>
              <button type="button" id="btnUpdateQueen">Update queen</button>
            </div>
          </form>

          <div class="custom-select-row">
            <div>
              <strong>Existing custom queens</strong><br />
              <select id="customQueenSelect">
                <option value="">(none)</option>
              </select>
            </div>
            <div style="display:flex; gap:0.4rem; align-items:flex-end; flex-wrap:wrap;">
              <button type="button" id="btnLoadForEdit">Edit</button>
              <button type="button" id="btnDeleteQueen">Remove</button>
            </div>
          </div>

          <div class="custom-preview">
            <div class="muted">Preview</div>
            <img id="customPreviewImage" src="" alt="" />
          </div>
        </div>
      </div>
    </section>

    <section>
      <h2>Season Output</h2>
      <div id="seasonContainer"></div>
    </section>
  </main>

  <!-- Data -->
  <script src="challenges.js"></script>
  <script src="mini-challenges.js"></script>
  <script src="queens.js"></script>

  <!-- Simulator -->
  <script src="sim.js"></script>

  <!-- UI / Rendering -->
  <script>
    const queensInput = document.getElementById("queensInput");
    const modeSelect = document.getElementById("modeSelect");
    const viewSelect = document.getElementById("viewSelect");
    const immunityToggle = document.getElementById("immunityToggle");
    const doubleTwistsToggle = document.getElementById("doubleTwistsToggle");
    const loadDefaultBtn = document.getElementById("loadDefaultQueens");
    const simulateBtn = document.getElementById("simulateButton");
    const seasonContainer = document.getElementById("seasonContainer");

    // Cast builder elements
    const castSizeRange = document.getElementById("castSizeRange");
    const castSizeLabel = document.getElementById("castSizeLabel");
    const queenGrid = document.getElementById("queenGrid");
    const btnRandomAll = document.getElementById("btnRandomAll");
    const btnRandomCustoms = document.getElementById("btnRandomCustoms");
    const btnClearCast = document.getElementById("btnClearCast");

    // Custom queen editor elements
    const customNameInput = document.getElementById("customName");
    const statActing = document.getElementById("statActing");
    const statComedy = document.getElementById("statComedy");
    const statDance = document.getElementById("statDance");
    const statDesign = document.getElementById("statDesign");
    const statImprov = document.getElementById("statImprov");
    const statRunway = document.getElementById("statRunway");
    const statSinging = document.getElementById("statSinging");
    const statLipsync = document.getElementById("statLipsync");
    const customImageUrlInput = document.getElementById("customImageUrl");
    const btnRandomizeStats = document.getElementById("btnRandomizeStats");
    const btnAddQueen = document.getElementById("btnAddQueen");
    const btnUpdateQueen = document.getElementById("btnUpdateQueen");
    const customQueenSelect = document.getElementById("customQueenSelect");
    const btnLoadForEdit = document.getElementById("btnLoadForEdit");
    const btnDeleteQueen = document.getElementById("btnDeleteQueen");
    const customPreviewImage = document.getElementById("customPreviewImage");

    // For Full view
    let currentSteps = [];
    let currentStepIndex = 0;

    // Number of main episodes actually logged (Episode 1..N)
    let seasonEpisodeCount = 0;

    // ---- Queen data for cast builder ----
    const CUSTOM_STORAGE_KEY = "drag_race_sim_custom_queens";

    let baseQueenDefs = [];   // canonical from queens.js
    let defaultQueens = [];   // with ids / imageUrl / source
    let customQueens = [];
    let allQueens = [];
    let currentCast = [];

    function slugify(name) {
      return (
        name
          .toLowerCase()
          .replace(/[^a-z0-9]+/g, "-")
          .replace(/^-|-$/g, "") || "queen-" + Date.now()
      );
    }

    function loadCustomQueens() {
      try {
        const raw = localStorage.getItem(CUSTOM_STORAGE_KEY);
        if (!raw) return [];
        const parsed = JSON.parse(raw);
        if (!Array.isArray(parsed)) return [];
        return parsed;
      } catch (e) {
        console.warn("Failed to parse custom queens from storage:", e);
        return [];
      }
    }

    function saveCustomQueens(list) {
      try {
        localStorage.setItem(CUSTOM_STORAGE_KEY, JSON.stringify(list));
      } catch (e) {
        console.warn("Failed to save custom queens:", e);
      }
    }

    function getCastLimit() {
      return parseInt(castSizeRange.value, 10) || 12;
    }

    function syncCastSizeLabel() {
      const n = getCastLimit();
      castSizeLabel.textContent = `${n} queens`;
    }

    castSizeRange.addEventListener("input", syncCastSizeLabel);

    function renderCastPicker() {
      queenGrid.innerHTML = "";
      if (!allQueens.length) {
        queenGrid.textContent = "No queens available.";
        return;
      }

      allQueens.forEach((q) => {
        const card = document.createElement("div");
        card.className = "queen-card";
        card.dataset.id = q.id;

        const img = document.createElement("img");
        img.src = q.imageUrl || "";
        img.alt = q.name;
        card.appendChild(img);

        const name = document.createElement("div");
        name.className = "queen-name";
        name.textContent = q.name;
        card.appendChild(name);

        if (q.source === "custom") {
          const badge = document.createElement("span");
          badge.className = "custom-badge";
          badge.textContent = "Custom";
          card.appendChild(badge);
        }

        if (currentCast.find((c) => c.id === q.id)) {
          card.classList.add("selected");
        }

        card.addEventListener("click", () => toggleQueenInCast(q.id, card));
        queenGrid.appendChild(card);
      });
    }

    function toggleQueenInCast(id, cardEl) {
      const existingIndex = currentCast.findIndex((q) => q.id === id);
      const limit = getCastLimit();

      if (existingIndex >= 0) {
        currentCast.splice(existingIndex, 1);
        if (cardEl) cardEl.classList.remove("selected");
      } else {
        if (currentCast.length >= limit) return;
        const q = allQueens.find((q) => q.id === id);
        if (!q) return;
        currentCast.push(q);
        if (cardEl) cardEl.classList.add("selected");
      }
    }

    function pickRandomQueens(sourceList, n) {
      const pool = [...sourceList];
      const out = [];
      while (pool.length && out.length < n) {
        const idx = Math.floor(Math.random() * pool.length);
        out.push(pool.splice(idx, 1)[0]);
      }
      return out;
    }

    btnRandomAll.addEventListener("click", () => {
      const limit = getCastLimit();
      currentCast = pickRandomQueens(allQueens, limit);
      renderCastPicker();
    });

    btnRandomCustoms.addEventListener("click", () => {
      const limit = getCastLimit();
      currentCast = pickRandomQueens(customQueens, limit);
      renderCastPicker();
    });

    btnClearCast.addEventListener("click", () => {
      currentCast = [];
      renderCastPicker();
    });

    // ---- Custom queen editor ----
    function formToQueen(idOverride) {
      const name = customNameInput.value.trim();
      if (!name) return null;

      const stats = {
        acting:  Number(statActing.value)  || 0,
        comedy:  Number(statComedy.value)  || 0,
        dance:   Number(statDance.value)   || 0,
        design:  Number(statDesign.value)  || 0,
        improv:  Number(statImprov.value)  || 0,
        runway:  Number(statRunway.value)  || 0,
        singing: Number(statSinging.value) || 0,
        lipsync: Number(statLipsync.value) || 0
      };

      const id = idOverride || slugify(name);

      return {
        id,
        name,
        imageUrl: customImageUrlInput.value.trim(),
        stats,
        traits: {},
        edits: [],
        source: "custom"
      };
    }

    function randomStat() {
      // 0â€“10 inclusive
      return Math.floor(Math.random() * 11);
    }

    btnRandomizeStats.addEventListener("click", () => {
      statActing.value  = randomStat();
      statComedy.value  = randomStat();
      statDance.value   = randomStat();
      statDesign.value  = randomStat();
      statImprov.value  = randomStat();
      statRunway.value  = randomStat();
      statSinging.value = randomStat();
      statLipsync.value = randomStat();
    });

    btnAddQueen.addEventListener("click", () => {
      const q = formToQueen();
      if (!q) {
        alert("Please enter a name for the queen.");
        return;
      }
      customQueens.push(q);
      saveCustomQueens(customQueens);
      allQueens = [...defaultQueens, ...customQueens];
      renderCustomQueenSelect();
      renderCastPicker();
    });

    btnUpdateQueen.addEventListener("click", () => {
      const selectedId = customQueenSelect.value;
      if (!selectedId) {
        alert("Select a custom queen to update.");
        return;
      }
      const idx = customQueens.findIndex((q) => q.id === selectedId);
      if (idx === -1) return;
      const q = formToQueen(selectedId);
      if (!q) return;
      customQueens[idx] = q;
      saveCustomQueens(customQueens);
      allQueens = [...defaultQueens, ...customQueens];
      renderCustomQueenSelect();
      renderCastPicker();
    });

    function renderCustomQueenSelect() {
      customQueenSelect.innerHTML = "";
      const noneOpt = document.createElement("option");
      noneOpt.value = "";
      noneOpt.textContent = "(none)";
      customQueenSelect.appendChild(noneOpt);

      customQueens.forEach((q) => {
        const opt = document.createElement("option");
        opt.value = q.id;
        opt.textContent = q.name;
        customQueenSelect.appendChild(opt);
      });

      updatePreviewFromSelect();
    }

    function updatePreviewFromSelect() {
      const id = customQueenSelect.value;
      const q = customQueens.find((cq) => cq.id === id);
      if (q && q.imageUrl) {
        customPreviewImage.src = q.imageUrl;
        customPreviewImage.alt = q.name;
      } else {
        customPreviewImage.src = "";
        customPreviewImage.alt = "";
      }
    }

    customQueenSelect.addEventListener("change", updatePreviewFromSelect);

    btnLoadForEdit.addEventListener("click", () => {
      const id = customQueenSelect.value;
      if (!id) return;
      const q = customQueens.find((cq) => cq.id === id);
      if (!q) return;
      customNameInput.value = q.name;
      customImageUrlInput.value = q.imageUrl || "";
      statActing.value  = q.stats?.acting  ?? 0;
      statComedy.value  = q.stats?.comedy  ?? 0;
      statDance.value   = q.stats?.dance   ?? 0;
      statDesign.value  = q.stats?.design  ?? 0;
      statImprov.value  = q.stats?.improv  ?? 0;
      statRunway.value  = q.stats?.runway  ?? 0;
      statSinging.value = q.stats?.singing ?? 0;
      statLipsync.value = q.stats?.lipsync ?? 0;
    });

    btnDeleteQueen.addEventListener("click", () => {
      const id = customQueenSelect.value;
      if (!id) return;
      if (!confirm("Remove this custom queen?")) return;
      customQueens = customQueens.filter((q) => q.id !== id);
      saveCustomQueens(customQueens);
      allQueens = [...defaultQueens, ...customQueens];
      currentCast = currentCast.filter((q) => q.id !== id);
      renderCustomQueenSelect();
      renderCastPicker();
    });

    // ---- Existing JSON / season rendering logic ----

    loadDefaultBtn.addEventListener("click", () => {
      queensInput.value = JSON.stringify(baseQueenDefs, null, 2);
    });

    // ---------- Parsing helpers ----------
    function parseSeasonLog(log) {
      const lines = log.split("\n");
      const header = [];
      const episodes = [];
      const finale = [];

      let section = "header";
      let current = null;

      for (const line of lines) {
        if (line.startsWith("========== Episode ")) {
          if (current) episodes.push(current);
          current = { lines: [line] };
          section = "episode";
        } else if (
          line.startsWith("========== Final 3") ||
          line.startsWith("========== Grand Finale")
        ) {
          if (current) episodes.push(current);
          current = null;
          section = "finale";
          finale.push(line);
        } else {
          if (section === "header") header.push(line);
          else if (section === "episode") current.lines.push(line);
          else finale.push(line);
        }
      }
      if (current) episodes.push(current);
      return { header, episodes, finale };
    }

    function filterHeader(lines) {
      const out = [];
      let skip = false;
      for (const l of lines) {
        if (l.startsWith("Planned must-have challenges:")) {
          skip = true;
          continue;
        }
        if (skip) {
          if (l.trim() === "") skip = false;
          continue;
        }
        out.push(l);
      }
      return out.filter((l) => l.trim());
    }

    // Hide main-score blocks AND mini-score blocks in episodes, keep mini header + winner.
    function filterEpisode(lines) {
      const out = [];
      let skipMainScores = false;
      let skipMiniScores = false;

      for (const l of lines) {
        const trimmed = l.trim();

        if (trimmed.startsWith("Scores this week:")) {
          skipMainScores = true;
          continue;
        }
        if (skipMainScores) {
          if (trimmed === "") {
            skipMainScores = false;
          }
          continue;
        }

        if (trimmed.startsWith("Mini-challenge scores:")) {
          skipMiniScores = true;
          continue;
        }
        if (skipMiniScores) {
          if (trimmed.startsWith("Mini-challenge winner:")) {
            skipMiniScores = false;
            out.push(l);
          }
          continue;
        }

        out.push(l);
      }
      return out;
    }

    // For SUMMARY view only â€“ strip raw lip-sync performance block
    function filterFinale(lines) {
      const out = [];
      let skip = false;
      for (const l of lines) {
        if (l.startsWith("Final lip sync performance:")) {
          skip = true;
          continue;
        }
        if (skip) {
          if (l.trim() === "") skip = false;
          continue;
        }
        out.push(l);
      }
      return out.filter((l) => l.trim());
    }

    // ---------- Summary view rendering ----------
    function renderSeasonSummary(log) {
      seasonContainer.innerHTML = "";
      const { header, episodes, finale } = parseSeasonLog(log);

      const cast = filterHeader(header);
      if (cast.length) {
        const card = document.createElement("div");
        card.className = "episode-card header-card";
        card.innerHTML = `<h3>Cast</h3><pre>${cast.join("\n")}</pre>`;
        seasonContainer.appendChild(card);
      }

      for (const ep of episodes) {
        const lines = filterEpisode(ep.lines);
        const title = lines[0] || "";
        const m = title.match(/Episode (\d+) â€” (.+?) =+/);
        const label = m ? `Episode ${m[1]} â€” ${m[2]}` : title;

        const d = document.createElement("details");
        d.className = "episode-card";

        const s = document.createElement("summary");
        s.textContent = label;
        d.appendChild(s);

        const p = document.createElement("pre");
        p.textContent = lines.join("\n");
        d.appendChild(p);

        seasonContainer.appendChild(d);
      }

      if (finale.length) {
        const d = document.createElement("details");
        d.className = "episode-card finale-card";
        d.open = false;

        const s = document.createElement("summary");
        s.textContent = "Grand Finale & Track Records";
        d.appendChild(s);

        const p = document.createElement("pre");
        p.textContent = filterFinale(finale).join("\n");
        d.appendChild(p);

        seasonContainer.appendChild(d);
      }
    }

    // ---------- Full (step-through) view ----------
    function buildStepsFromLog(log) {
      const { header, episodes, finale } = parseSeasonLog(log);
      const steps = [];

      // Canonical number of main episodes for track-record table
      seasonEpisodeCount = episodes.length;

      const castLines = filterHeader(header);
      if (castLines.length) {
        steps.push({ type: "cast", lines: castLines });
      }

      episodes.forEach((ep, index) => {
        const filtered = filterEpisode(ep.lines);
        const titleLine = filtered[0] || ep.lines[0] || "";
        const m = titleLine.match(/Episode (\d+) â€” (.+?) =+/);
        const epNum = m ? parseInt(m[1], 10) : index + 1;
        const epName = m ? m[2] : "Unknown challenge";

        steps.push({ type: "episode_setup", epNum, name: epName });

        // Mini-challenge block
        let miniLines = [];
        let miniName = null;
        let inMini = false;

        for (const line of filtered) {
          const trimmed = line.trim();

          if (trimmed.startsWith("Mini-Challenge â€”")) {
            inMini = true;
            miniLines.push(line);
            const mm = trimmed.match(/^Mini-Challenge â€” (.+)$/);
            if (mm) miniName = mm[1];
            continue;
          }

          if (inMini) {
            if (trimmed.startsWith("Results:")) {
              inMini = false;
              continue;
            }
            miniLines.push(line);
          }
        }

        if (miniLines.length) {
          steps.push({
            type: "episode_mini",
            epNum,
            name: epName,
            miniName,
            lines: miniLines.filter((l) => l.trim() !== ""),
          });
        }

        // Main challenge results
        const resultsLines = [];
        let inResults = false;
        for (const line of filtered) {
          if (line.startsWith("Results:")) {
            inResults = true;
            resultsLines.push(line);
            continue;
          }
          if (inResults) {
            resultsLines.push(line);
          }
        }
        const cleanResults = resultsLines.filter((l) => l.trim() !== "");
        steps.push({
          type: "episode_results",
          epNum,
          name: epName,
          lines: cleanResults,
        });
      });

      // For Full view we keep raw finale lines (no filterFinale),
      // so we can parse actual season scores.
      const finaleLines = finale;
      if (finaleLines.length) {
        const idx = finaleLines.findIndex((l) =>
          l.startsWith("========== Grand Finale")
        );
        if (idx > 0) {
          const final3Lines = finaleLines.slice(0, idx).filter((l) => l.trim());
          const finaleRest = finaleLines.slice(idx).filter((l) => l.trim());
          if (final3Lines.length) steps.push({ type: "final3", lines: final3Lines });
          if (finaleRest.length) steps.push({ type: "finale", lines: finaleRest });
        } else {
          steps.push({ type: "finale", lines: finaleLines });
        }
      }

      return steps;
    }

    function renderResultsLines(lines, card) {
      const block = document.createElement("div");
      block.className = "results-block";

      let headingAdded = false;
      for (const line of lines) {
        const trimmed = line.trim();
        if (!trimmed) continue;

        if (trimmed.startsWith("Results:")) {
          const h = document.createElement("div");
          h.className = "results-heading";
          h.textContent = "Results";
          block.appendChild(h);
          headingAdded = true;
          continue;
        }

        const row = document.createElement("div");
        row.className = "results-row";

        const colonIdx = trimmed.indexOf(":");
        if (colonIdx !== -1) {
          const label = trimmed.slice(0, colonIdx).trim();
          const value = trimmed.slice(colonIdx + 1).trim();
          const strong = document.createElement("strong");
          strong.textContent = label + ":";
          row.appendChild(strong);
          row.appendChild(document.createTextNode(" " + value));
        } else {
          row.textContent = trimmed;
        }
        block.appendChild(row);
      }

      if (!headingAdded && lines.length) {
        const h = document.createElement("div");
        h.className = "results-heading";
        h.textContent = "Results";
        block.insertBefore(h, block.firstChild);
      }

      card.appendChild(block);
    }

    function renderMiniLines(step, card) {
      const block = document.createElement("div");
      block.className = "results-block";

      const heading = document.createElement("div");
      heading.className = "results-heading";
      heading.textContent = "Mini-Challenge";
      block.appendChild(heading);

      const challengeRow = document.createElement("div");
      challengeRow.className = "results-row";
      const challengeLabel = document.createElement("strong");
      challengeLabel.textContent = "Challenge:";
      challengeRow.appendChild(challengeLabel);
      challengeRow.appendChild(
        document.createTextNode(" " + (step.miniName || "Mini-Challenge"))
      );
      block.appendChild(challengeRow);

      let winnerName = "Unknown";
      for (const line of step.lines) {
        const trimmed = line.trim();
        const lower = trimmed.toLowerCase();
        if (lower.startsWith("mini-challenge winner:")) {
          const parts = trimmed.split(":");
          if (parts.length > 1) {
            winnerName = parts.slice(1).join(":").trim();
          }
          break;
        }
      }

      const winnerRow = document.createElement("div");
      winnerRow.className = "results-row";
      const winnerLabel = document.createElement("strong");
      winnerLabel.textContent = "Winner:";
      winnerRow.appendChild(winnerLabel);
      winnerRow.appendChild(document.createTextNode(" " + winnerName));
      block.appendChild(winnerRow);

      card.appendChild(block);
    }

    function renderFinaleLines(lines, card) {
      const block = document.createElement("div");
      block.className = "results-block";

      const heading = document.createElement("div");
      heading.className = "results-heading";
      heading.textContent = "Grand Finale";
      block.appendChild(heading);

      const finalists = [];
      let winnerName = "Unknown";

      let inTrackSection = false;
      const trackLines = [];
      const seasonScoreMap = new Map();

      for (const line of lines) {
        const trimmed = line.trim();

        // Extract exact season scores: "Name  season=  8.0  raw_lip=..."
        const mSeason = trimmed.match(/^(.+?)\s+season=([0-9.+-]+)/);
        if (mSeason) {
          const name = mSeason[1].trim();
          const seasonScore = parseFloat(mSeason[2]);
          if (name && !Number.isNaN(seasonScore)) {
            seasonScoreMap.set(name, seasonScore);
          }
        }

        // Start of track-record block
        if (trimmed === "Full track records:") {
          inTrackSection = true;
          continue;
        }
        if (inTrackSection) {
          trackLines.push(trimmed);
          continue;
        }

        // Finalists bullets: "- Queen Name (track: ...)"
        if (trimmed.startsWith("- ")) {
          const noDash = trimmed.slice(2).trim();
          const trackIdx = noDash.indexOf("(track:");
          const name = trackIdx === -1 ? noDash : noDash.slice(0, trackIdx).trim();
          if (name) finalists.push(name);
        }

        // Winner line: "X devours the stage and snatches the crown! ðŸ‘‘"
        if (
          trimmed.endsWith("snatches the crown! ðŸ‘‘") ||
          trimmed.endsWith("snatches the crown!")
        ) {
          const marker = " devours the stage";
          const idx = trimmed.indexOf(marker);
          if (idx !== -1) {
            winnerName = trimmed.slice(0, idx).trim();
          }
        }
      }

      if (finalists.length) {
        const finalistsRow = document.createElement("div");
        finalistsRow.className = "results-row";
        const finalistsLabel = document.createElement("strong");
        finalistsLabel.textContent = "Finalists:";
        finalistsRow.appendChild(finalistsLabel);
        finalistsRow.appendChild(
          document.createTextNode(" " + finalists.join(", "))
        );
        block.appendChild(finalistsRow);
      }

      const winnerRow = document.createElement("div");
      winnerRow.className = "results-row";
      const winnerLabel = document.createElement("strong");
      winnerLabel.textContent = "Winner:";
      winnerRow.appendChild(winnerLabel);
      winnerRow.appendChild(document.createTextNode(" " + winnerName));
      block.appendChild(winnerRow);

      card.appendChild(block);

      // Helper: fallback season score from record only (if needed)
      function seasonScoreFromRecord(rec) {
        let score = 0;
        for (const raw of rec) {
          const r = raw.replace(/\(IMM\)$/, "");
          if (r === "WIN") score += 3;
          else if (r === "HIGH") score += 1;
          else if (r === "LOW") score -= 1;
          else if (r === "BTM") score -= 2;
        }
        return score;
      }

      // Track records table
      if (trackLines.length) {
        const records = [];
        const statusSet = new Set(["WIN", "HIGH", "SAFE", "LOW", "BTM", "ELIM"]);

        for (const line of trackLines) {
          if (!line) continue;
          const parts = line.split(/\s+/);
          if (!parts.length) continue;

          let firstStatusIdx = -1;
          for (let i = 0; i < parts.length; i++) {
            const base = parts[i].replace(/\(IMM\)$/, "");
            if (statusSet.has(base)) {
              firstStatusIdx = i;
              break;
            }
          }
          if (firstStatusIdx === -1) continue;

          const name = parts.slice(0, firstStatusIdx).join(" ");
          const rec = parts.slice(firstStatusIdx);
          if (!name) continue;

          const elimIdx = rec.findIndex((s) => {
            const base = s.replace(/\(IMM\)$/, "");
            return base === "ELIM";
          });

          records.push({
            name,
            record: rec,
            elimIndex: elimIdx === -1 ? Infinity : elimIdx,
          });
        }

        // Sort: finalists (no ELIM) at top, earliest eliminated last
        records.sort((a, b) => b.elimIndex - a.elimIndex);

        // Decide finale ranking using real season scores where possible
        const finalistsSet = new Set(finalists);

        const finalistRecords = records
          .filter((r) => finalistsSet.has(r.name))
          .map((r) => {
            const fallback = seasonScoreFromRecord(r.record);
            const seasonScore = seasonScoreMap.has(r.name)
              ? seasonScoreMap.get(r.name)
              : fallback;
            return { ...r, seasonScore };
          });

        // Sort finalists by season score, then ensure the actual winner is first
        finalistRecords.sort((a, b) => b.seasonScore - a.seasonScore);
        const winnerIdx = finalistRecords.findIndex((r) => r.name === winnerName);
        if (winnerIdx > 0) {
          const [w] = finalistRecords.splice(winnerIdx, 1);
          finalistRecords.unshift(w);
        }

        const finishOrderNames = finalistRecords.map((r) => r.name);
        const secondName = finishOrderNames[1] || null;
        const thirdName = finishOrderNames[2] || null;

        // Rebuild records so finalists appear in finish order at the top
        const finalistsByName = new Set(finishOrderNames);
        const nonFinalistsOrdered = records.filter(
          (r) => !finalistsByName.has(r.name)
        );
        const finalRecords = [
          ...finalistRecords.map(({ name, record, elimIndex }) => ({
            name,
            record,
            elimIndex,
          })),
          ...nonFinalistsOrdered,
        ];

        if (finalRecords.length) {
          let maxEpisodes = 0;
          for (const r of finalRecords) {
            if (r.record.length > maxEpisodes) maxEpisodes = r.record.length;
          }

          const numEpisodeCols = seasonEpisodeCount || maxEpisodes;

          const table = document.createElement("table");
          table.className = "track-record-table";

          const thead = document.createElement("thead");
          const headRow = document.createElement("tr");

          const thName = document.createElement("th");
          thName.textContent = "Contestant";
          headRow.appendChild(thName);

          for (let i = 0; i < numEpisodeCols; i++) {
            const th = document.createElement("th");
            th.textContent = String(i + 1);
            headRow.appendChild(th);
          }
          const thFinale = document.createElement("th");
          thFinale.textContent = "Finale";
          headRow.appendChild(thFinale);

          thead.appendChild(headRow);
          table.appendChild(thead);

          const tbody = document.createElement("tbody");
          for (const r of finalRecords) {
            const tr = document.createElement("tr");

            const tdName = document.createElement("td");
            tdName.textContent = r.name;
            tdName.className = "track-name";
            tr.appendChild(tdName);

            for (let i = 0; i <= numEpisodeCols; i++) {
              const td = document.createElement("td");

              if (i < numEpisodeCols) {
                const rawStatus = r.record[i] || "";
                const hasImmunity = rawStatus.endsWith("(IMM)");
                const baseStatus = hasImmunity
                  ? rawStatus.replace(/\(IMM\)$/, "")
                  : rawStatus;

                const cls =
                  "status-" + (baseStatus ? baseStatus.toLowerCase() : "empty");
                td.className = cls;

                if (!baseStatus) {
                  td.textContent = "";
                } else if (hasImmunity) {
                  const mainDiv = document.createElement("div");
                  mainDiv.textContent = baseStatus;
                  const immDiv = document.createElement("div");
                  immDiv.textContent = "(IMM)";
                  immDiv.className = "status-immunity-tag";
                  td.appendChild(mainDiv);
                  td.appendChild(immDiv);
                } else {
                  td.textContent = baseStatus;
                }
              } else {
                // Finale column: 1st / 2nd / 3rd
                let text = "";
                let cls = "status-empty";
                if (r.name === winnerName) {
                  text = "WINNER";
                  cls = "status-finale-winner";
                } else if (r.name === secondName) {
                  text = "RUNNER-UP";
                  cls = "status-finale-runner";
                } else if (r.name === thirdName) {
                  text = "RUNNER-UP";
                  cls = "status-finale-runner-bronze";
                }
                td.className = cls;
                td.textContent = text;
              }

              tr.appendChild(td);
            }

            tbody.appendChild(tr);
          }

          table.appendChild(tbody);
          card.appendChild(table);
        }
      }
    }

    function getNextLabel(step, index, total) {
      const isLast = index === total - 1;
      if (isLast) return "Restart Season";

      const nextStep = currentSteps[index + 1] || null;

      switch (step.type) {
        case "cast":
          if (nextStep && nextStep.type === "episode_setup") {
            return "Proceed to Episode 1";
          }
          return "Proceed";
        case "episode_setup":
          if (nextStep && nextStep.type === "episode_mini") {
            return "Proceed to Mini-Challenge";
          }
          if (nextStep && nextStep.type === "episode_results") {
            return "Proceed to Judging";
          }
          return "Proceed";
        case "episode_mini":
          if (nextStep && nextStep.type === "episode_results") {
            return "Proceed to Judging";
          }
          return "Proceed";
        case "episode_results":
          return "Next Episode";
        case "final3":
          return "Proceed to Grand Finale";
        default:
          return "Proceed";
      }
    }

    function renderCurrentStep() {
      seasonContainer.innerHTML = "";
      if (!currentSteps.length) {
        seasonContainer.textContent = "No steps available.";
        return;
      }
      const step = currentSteps[currentStepIndex];

      const card = document.createElement("div");
      card.className = "episode-card step-" + step.type;

      const meta = document.createElement("div");
      meta.className = "step-meta";
      meta.textContent =
        "Step " + (currentStepIndex + 1) + " of " + currentSteps.length;
      card.appendChild(meta);

      const h = document.createElement("h3");
      let titleText = "";
      let bodyLines = [];

      switch (step.type) {
        case "cast":
          titleText = "Cast Reveal";
          bodyLines = step.lines;
          break;
        case "episode_setup":
          titleText = `Episode ${step.epNum} â€” ${step.name}`;
          bodyLines = [
            `In Episode ${step.epNum}, the queens face the ${step.name}.`,
            "",
            "Proceed to see the judging and results.",
          ];
          break;
        case "episode_mini":
          titleText = `Episode ${step.epNum} â€” Mini-Challenge: ${
            step.miniName || "Mini-Challenge"
          }`;
          bodyLines = step.lines;
          break;
        case "episode_results":
          titleText = `Episode ${step.epNum} â€” Judging & Results`;
          bodyLines = step.lines;
          break;
        case "final3":
          titleText = "Final 3 Revealed";
          bodyLines = step.lines;
          break;
        case "finale":
          titleText = "Grand Finale & Track Records";
          bodyLines = step.lines;
          break;
        default:
          titleText = "Season";
          bodyLines = [];
      }

      h.textContent = titleText;
      card.appendChild(h);

      if (bodyLines.length) {
        if (step.type === "episode_setup") {
          const p = document.createElement("p");
          p.textContent = bodyLines.join("\n");
          card.appendChild(p);
        } else if (step.type === "episode_results") {
          renderResultsLines(bodyLines, card);
        } else if (step.type === "episode_mini") {
          renderMiniLines(step, card);
        } else if (step.type === "finale") {
          renderFinaleLines(bodyLines, card);
        } else {
          const pre = document.createElement("pre");
          pre.textContent = bodyLines.join("\n");
          card.appendChild(pre);
        }
      }

      const nav = document.createElement("div");
      nav.className = "step-nav";

      const backBtn = document.createElement("button");
      backBtn.textContent = "Back";
      backBtn.disabled = currentStepIndex === 0;
      backBtn.addEventListener("click", () => {
        if (currentStepIndex > 0) {
          currentStepIndex--;
          renderCurrentStep();
        }
      });

      const nextBtn = document.createElement("button");
      nextBtn.textContent = getNextLabel(
        step,
        currentStepIndex,
        currentSteps.length
      );
      nextBtn.addEventListener("click", () => {
        if (currentStepIndex === currentSteps.length - 1) {
          currentStepIndex = 0;
        } else {
          currentStepIndex++;
        }
        renderCurrentStep();
      });

      nav.appendChild(backBtn);
      nav.appendChild(nextBtn);
      card.appendChild(nav);

      seasonContainer.appendChild(card);
    }

    function renderSeasonFull(log) {
      currentSteps = buildStepsFromLog(log);
      currentStepIndex = 0;
      renderCurrentStep();
    }

    // ---------- Main simulate handler ----------
    simulateBtn.addEventListener("click", () => {
      let queens;
      if (currentCast.length > 0) {
        queens = currentCast;
      } else {
        try {
          queens = JSON.parse(queensInput.value);
        } catch (e) {
          alert("Queens JSON is invalid.");
          return;
        }
      }

      const mode = modeSelect.value;
      const view = viewSelect.value;
      const immunityEnabled = immunityToggle.checked;
      const doubleLipSyncTwistsEnabled = doubleTwistsToggle.checked;

      const log = window.simulateSeason(queens, {
        mode,
        immunityEnabled,
        doubleLipSyncTwistsEnabled,
      });

      if (view === "summary") {
        renderSeasonSummary(log);
      } else {
        renderSeasonFull(log);
      }
    });

    // Auto-load sample cast and initialise cast builder
    window.addEventListener("DOMContentLoaded", () => {
      baseQueenDefs = window.QUEENS || [];
      defaultQueens = baseQueenDefs.map((q, idx) => ({
        ...q,
        id: q.id || slugify(q.name || "queen-" + idx),
        imageUrl: q.imageUrl || "",
        source: "default"
      }));
      customQueens = loadCustomQueens();
      allQueens = [...defaultQueens, ...customQueens];

      // Show canonical defs (without id/source/imageUrl) in the JSON box
      queensInput.value = JSON.stringify(baseQueenDefs, null, 2);

      syncCastSizeLabel();
      renderCustomQueenSelect();
      renderCastPicker();
    });
  </script>
</body>
</html>
