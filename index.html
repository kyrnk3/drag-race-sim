<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Drag Race Season Simulator</title>
  <link rel="stylesheet" href="style.css" />

  <!-- Card / collapsible styling -->
  <style>
    body {
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      background: #111;
      color: #eee;
      margin: 0;
    }

    .app {
      max-width: 960px;
      margin: 0 auto;
      padding: 1.5rem;
    }

    h1, h2 {
      text-align: center;
      margin-top: 0;
    }

    .controls {
      background: #1b1b1b;
      padding: 1rem;
      border-radius: 8px;
      margin-bottom: 1.5rem;
      box-shadow: 0 0 0 1px #222;
    }

    .control-row {
      margin-bottom: 0.75rem;
      display: flex;
      align-items: center;
      gap: 0.5rem;
      flex-wrap: wrap;
    }

    textarea {
      width: 100%;
      font-family: monospace;
      font-size: 0.85rem;
      background: #000;
      color: #eee;
      border-radius: 4px;
      border: 1px solid #444;
      padding: 0.5rem;
      resize: vertical;
    }

    select {
      background: #000;
      color: #eee;
      border-radius: 4px;
      border: 1px solid #444;
      padding: 0.2rem 0.4rem;
    }

    button {
      padding: 0.4rem 0.8rem;
      border-radius: 4px;
      border: none;
      cursor: pointer;
      background: #e91e63;
      color: #fff;
      font-weight: 600;
    }

    button:hover:not(:disabled) {
      filter: brightness(1.1);
    }

    button:disabled {
      opacity: 0.4;
      cursor: default;
    }

    .episode-card {
      background: #161616;
      border-radius: 8px;
      padding: 0.75rem 1rem;
      margin-bottom: 0.75rem;
      box-shadow: 0 0 0 1px #222;
      border-left: 3px solid #444;
    }

    .header-card {
      border-left-color: #e91e63;
    }

    .finale-card {
      border-left-color: #ffc107;
    }

    details.episode-card > summary {
      cursor: pointer;
      font-weight: 600;
      list-style: none;
    }

    details.episode-card > summary::-webkit-details-marker {
      display: none;
    }

    details.episode-card > summary::before {
      content: "â–¶";
      display: inline-block;
      margin-right: 0.4rem;
      font-size: 0.8rem;
    }

    details.episode-card[open] > summary::before {
      content: "â–¼";
    }

    .episode-card pre {
      white-space: pre-wrap;
      font-size: 0.8rem;
      margin: 0.5rem 0 0;
      font-family: Menlo, Consolas, monospace;
    }

    /* Full-view step styling */
    .step-cast {
      border-left-color: #e91e63;
    }

    .step-episode_setup {
      border-left-color: #9c27b0;
    }

    .step-episode_mini {
      border-left-color: #4caf50;
    }

    .step-episode_results {
      border-left-color: #ff9800;
    }

    .step-final3 {
      border-left-color: #03a9f4;
    }

    .step-finale {
      border-left-color: #ffc107;
      box-shadow: 0 0 12px rgba(255, 215, 0, 0.2);
    }

    .step-meta {
      font-size: 0.8rem;
      opacity: 0.8;
      margin-bottom: 0.25rem;
    }

    .episode-card h3 {
      margin: 0.25rem 0 0.5rem;
      text-align: left;
    }

    .episode-card p {
      margin: 0.5rem 0 0;
      font-size: 0.9rem;
      line-height: 1.4;
    }

    .results-block {
      margin-top: 0.5rem;
      font-size: 0.9rem;
    }

    .results-heading {
      font-weight: 700;
      margin-bottom: 0.3rem;
      text-transform: uppercase;
      letter-spacing: 0.05em;
      font-size: 0.8rem;
      opacity: 0.85;
    }

    .results-row {
      margin: 0.15rem 0;
    }

    .results-row strong {
      margin-right: 0.35rem;
    }

    .step-nav {
      margin-top: 0.75rem;
      display: flex;
      justify-content: space-between;
      gap: 0.5rem;
    }

    /* Track record table styling */
    .track-record-table {
      width: 100%;
      border-collapse: collapse;
      margin-top: 0.75rem;
      font-size: 0.8rem;
    }

    .track-record-table th,
    .track-record-table td {
      border: 1px solid #333;
      padding: 0.25rem 0.35rem;
      text-align: center;
    }

    .track-record-table th {
      background: #222;
      font-weight: 600;
    }

    .track-record-table .track-name {
      text-align: left;
      white-space: nowrap;
      background: #202020;
      position: sticky;
      left: 0;
      z-index: 1;
    }

    .track-record-table .status-empty {
      background: #181818;
    }

    .track-record-table .status-win {
      background: #3f51b5;
      color: #fff;
      font-weight: 700;
    }

    .track-record-table .status-high {
      background: #8bc6ff;
      color: #000;
    }

    .track-record-table .status-safe {
      background: #d0d0d0;
      color: #000;
    }

    .track-record-table .status-low {
      background: #ffccdf;
      color: #000;
    }

    .track-record-table .status-btm {
      background: #ff7043;
      color: #000;
      font-weight: 700;
    }

    .track-record-table .status-elim {
      background: #424242;
      color: #fff;
      font-weight: 700;
    }
  </style>
</head>
<body>
  <main class="app">
    <h1>Drag Race Season Simulator</h1>

    <section class="controls">
      <div class="control-row">
        <label>
          Mode:
          <select id="modeSelect">
            <option value="normal">Normal</option>
            <option value="chaos">Chaos</option>
          </select>
        </label>

        <label>
          View:
          <select id="viewSelect">
            <option value="summary">Summary</option>
            <option value="full">Full</option>
          </select>
        </label>
      </div>

      <div class="control-row" style="width:100%;">
        <label style="width:100%;">
          Queens JSON:
          <textarea id="queensInput" rows="10" spellcheck="false"></textarea>
        </label>
      </div>

      <div class="control-row">
        <button id="loadDefaultQueens">Load sample cast</button>
        <button id="simulateButton">Simulate Season</button>
      </div>
    </section>

    <section>
      <h2>Season Output</h2>
      <div id="seasonContainer"></div>
    </section>
  </main>

  <!-- Data -->
  <script src="challenges.js"></script>
  <script src="mini-challenges.js"></script>
  <script src="queens.js"></script>

  <!-- Simulator -->
  <script src="sim.js"></script>

  <!-- UI / Rendering -->
  <script>
    const queensInput = document.getElementById("queensInput");
    const modeSelect = document.getElementById("modeSelect");
    const viewSelect = document.getElementById("viewSelect");
    const loadDefaultBtn = document.getElementById("loadDefaultQueens");
    const simulateBtn = document.getElementById("simulateButton");
    const seasonContainer = document.getElementById("seasonContainer");

    // For Full view
    let currentSteps = [];
    let currentStepIndex = 0;

    loadDefaultBtn.addEventListener("click", () => {
      queensInput.value = JSON.stringify(window.QUEENS, null, 2);
    });

    // ---------- Parsing helpers ----------

    function parseSeasonLog(log) {
      const lines = log.split("\n");
      const header = [];
      const episodes = [];
      const finale = [];

      let section = "header";
      let current = null;

      for (const line of lines) {
        if (line.startsWith("========== Episode ")) {
          if (current) episodes.push(current);
          current = { lines: [line] };
          section = "episode";
        } else if (
          line.startsWith("========== Final 3") ||
          line.startsWith("========== Grand Finale")
        ) {
          if (current) episodes.push(current);
          current = null;
          section = "finale";
          finale.push(line);
        } else {
          if (section === "header") header.push(line);
          else if (section === "episode") current.lines.push(line);
          else finale.push(line);
        }
      }
      if (current) episodes.push(current);
      return { header, episodes, finale };
    }

    function filterHeader(lines) {
      const out = [];
      let skip = false;
      for (const l of lines) {
        if (l.startsWith("Planned must-have challenges:")) {
          skip = true;
          continue;
        }
        if (skip) {
          if (l.trim() === "") skip = false;
          continue;
        }
        out.push(l);
      }
      return out.filter(l => l.trim());
    }

    // Hide main-score blocks AND mini-score blocks, keep mini header + winner.
    function filterEpisode(lines) {
      const out = [];
      let skipMainScores = false;
      let skipMiniScores = false;

      for (const l of lines) {
        const trimmed = l.trim();

        // Main challenge score block ("Scores this week:")
        if (trimmed.startsWith("Scores this week:")) {
          skipMainScores = true;
          continue;
        }
        if (skipMainScores) {
          if (trimmed === "") {
            skipMainScores = false;
          }
          continue;
        }

        // Mini-challenge score block ("Mini-challenge scores:")
        if (trimmed.startsWith("Mini-challenge scores:")) {
          skipMiniScores = true;
          continue;
        }
        if (skipMiniScores) {
          // Stop skipping and include the winner line when we hit it.
          if (trimmed.startsWith("Mini-challenge winner:")) {
            skipMiniScores = false;
            out.push(l);
          }
          continue;
        }

        out.push(l);
      }
      return out;
    }

    function filterFinale(lines) {
      const out = [];
      let skip = false;
      for (const l of lines) {
        if (l.startsWith("Final lip sync performance:")) {
          skip = true;
          continue;
        }
        if (skip) {
          if (l.trim() === "") skip = false;
          continue;
        }
        out.push(l);
      }
      return out.filter(l => l.trim());
    }

    // ---------- Summary view rendering ----------

    function renderSeasonSummary(log) {
      seasonContainer.innerHTML = "";
      const { header, episodes, finale } = parseSeasonLog(log);

      const cast = filterHeader(header);
      if (cast.length) {
        const card = document.createElement("div");
        card.className = "episode-card header-card";
        card.innerHTML = `<h3>Cast</h3><pre>${cast.join("\n")}</pre>`;
        seasonContainer.appendChild(card);
      }

      for (const ep of episodes) {
        const lines = filterEpisode(ep.lines);
        const title = lines[0] || "";
        const m = title.match(/Episode (\d+) â€” (.+?) =+/);
        const label = m ? `Episode ${m[1]} â€” ${m[2]}` : title;

        const d = document.createElement("details");
        d.className = "episode-card";

        const s = document.createElement("summary");
        s.textContent = label;
        d.appendChild(s);

        const p = document.createElement("pre");
        p.textContent = lines.join("\n");
        d.appendChild(p);

        seasonContainer.appendChild(d);
      }

      if (finale.length) {
        const d = document.createElement("details");
          d.className = "episode-card finale-card";
        d.open = false;

        const s = document.createElement("summary");
        s.textContent = "Grand Finale & Track Records";
        d.appendChild(s);

        const p = document.createElement("pre");
        p.textContent = filterFinale(finale).join("\n");
        d.appendChild(p);

        seasonContainer.appendChild(d);
      }
    }

    // ---------- Full (step-through) view ----------

    function buildStepsFromLog(log) {
      const { header, episodes, finale } = parseSeasonLog(log);
      const steps = [];

      const castLines = filterHeader(header);
      if (castLines.length) {
        steps.push({ type: "cast", lines: castLines });
      }

      episodes.forEach((ep, index) => {
        const filtered = filterEpisode(ep.lines);
        const titleLine = filtered[0] || ep.lines[0] || "";
        const m = titleLine.match(/Episode (\d+) â€” (.+?) =+/);
        const epNum = m ? parseInt(m[1], 10) : index + 1;
        const epName = m ? m[2] : "Unknown challenge";

        // Setup step
        steps.push({ type: "episode_setup", epNum, name: epName });

        // Mini-challenge block (if present)
        let miniLines = [];
        let miniName = null;
        let inMini = false;

        for (const line of filtered) {
          const trimmed = line.trim();

          if (trimmed.startsWith("Mini-Challenge â€”")) {
            inMini = true;
            miniLines.push(line);
            const mm = trimmed.match(/^Mini-Challenge â€” (.+)$/);
            if (mm) miniName = mm[1];
            continue;
          }

          if (inMini) {
            if (trimmed.startsWith("Results:")) {
              inMini = false;
              continue;
            }
            miniLines.push(line);
          }
        }

        if (miniLines.length) {
          steps.push({
            type: "episode_mini",
            epNum,
            name: epName,
            miniName,
            lines: miniLines.filter(l => l.trim() !== "")
          });
        }

        // Main challenge results
        const resultsLines = [];
        let inResults = false;
        for (const line of filtered) {
          if (line.startsWith("Results:")) {
            inResults = true;
            resultsLines.push(line);
            continue;
          }
          if (inResults) {
            resultsLines.push(line);
          }
        }
        const cleanResults = resultsLines.filter(l => l.trim() !== "");
        steps.push({
          type: "episode_results",
          epNum,
          name: epName,
          lines: cleanResults
        });
      });

      const finaleLines = filterFinale(finale);
      if (finaleLines.length) {
        const idx = finaleLines.findIndex(l =>
          l.startsWith("========== Grand Finale")
        );
        if (idx > 0) {
          const final3Lines = finaleLines.slice(0, idx).filter(l => l.trim());
          const finaleRest = finaleLines.slice(idx).filter(l => l.trim());
          if (final3Lines.length) steps.push({ type: "final3", lines: final3Lines });
          if (finaleRest.length) steps.push({ type: "finale", lines: finaleRest });
        } else {
          steps.push({ type: "finale", lines: finaleLines });
        }
      }

      return steps;
    }

    function renderResultsLines(lines, card) {
      const block = document.createElement("div");
      block.className = "results-block";

      let headingAdded = false;
      for (const line of lines) {
        const trimmed = line.trim();
        if (!trimmed) continue;

        if (trimmed.startsWith("Results:")) {
          const h = document.createElement("div");
          h.className = "results-heading";
          h.textContent = "Results";
          block.appendChild(h);
          headingAdded = true;
          continue;
        }

        const row = document.createElement("div");
        row.className = "results-row";

        const colonIdx = trimmed.indexOf(":");
        if (colonIdx !== -1) {
          const label = trimmed.slice(0, colonIdx).trim();
          const value = trimmed.slice(colonIdx + 1).trim();
          const strong = document.createElement("strong");
          strong.textContent = label + ":";
          row.appendChild(strong);
          row.appendChild(document.createTextNode(" " + value));
        } else {
          row.textContent = trimmed;
        }
        block.appendChild(row);
      }

      if (!headingAdded && lines.length) {
        const h = document.createElement("div");
        h.className = "results-heading";
        h.textContent = "Results";
        block.insertBefore(h, block.firstChild);
      }

      card.appendChild(block);
    }

    function renderMiniLines(step, card) {
      const block = document.createElement("div");
      block.className = "results-block";

      const heading = document.createElement("div");
      heading.className = "results-heading";
      heading.textContent = "Mini-Challenge";
      block.appendChild(heading);

      const challengeRow = document.createElement("div");
      challengeRow.className = "results-row";
      const challengeLabel = document.createElement("strong");
      challengeLabel.textContent = "Challenge:";
      challengeRow.appendChild(challengeLabel);
      challengeRow.appendChild(
        document.createTextNode(" " + (step.miniName || "Mini-Challenge"))
      );
      block.appendChild(challengeRow);

      let winnerName = "Unknown";
      for (const line of step.lines) {
        const trimmed = line.trim();
        const lower = trimmed.toLowerCase();
        if (lower.startsWith("mini-challenge winner:")) {
          const parts = trimmed.split(":");
          if (parts.length > 1) {
            winnerName = parts.slice(1).join(":").trim();
          }
          break;
        }
      }

      const winnerRow = document.createElement("div");
      winnerRow.className = "results-row";
      const winnerLabel = document.createElement("strong");
      winnerLabel.textContent = "Winner:";
      winnerRow.appendChild(winnerLabel);
      winnerRow.appendChild(document.createTextNode(" " + winnerName));
      block.appendChild(winnerRow);

      card.appendChild(block);
    }

    function renderFinaleLines(lines, card) {
      const block = document.createElement("div");
      block.className = "results-block";

      const heading = document.createElement("div");
      heading.className = "results-heading";
      heading.textContent = "Grand Finale";
      block.appendChild(heading);

      const finalists = [];
      let winnerName = "Unknown";

      let inTrackSection = false;
      const trackLines = [];

      for (const line of lines) {
        const trimmed = line.trim();

        // Split out track-record section
        if (trimmed === "Full track records:") {
          inTrackSection = true;
          continue;
        }
        if (inTrackSection) {
          trackLines.push(trimmed);
          continue;
        }

        // Finalists bullets: "- Queen Name (track: ...)"
        if (trimmed.startsWith("- ")) {
          const noDash = trimmed.slice(2).trim();
          const trackIdx = noDash.indexOf("(track:");
          const name = trackIdx === -1 ? noDash : noDash.slice(0, trackIdx).trim();
          if (name) finalists.push(name);
        }

        // Winner line: "X devours the stage and snatches the crown! ðŸ‘‘"
        if (
          trimmed.endsWith("snatches the crown! ðŸ‘‘") ||
          trimmed.endsWith("snatches the crown!")
        ) {
          const marker = " devours the stage";
          const idx = trimmed.indexOf(marker);
          if (idx !== -1) {
            winnerName = trimmed.slice(0, idx).trim();
          }
        }
      }

      if (finalists.length) {
        const finalistsRow = document.createElement("div");
        finalistsRow.className = "results-row";
        const finalistsLabel = document.createElement("strong");
        finalistsLabel.textContent = "Finalists:";
        finalistsRow.appendChild(finalistsLabel);
        finalistsRow.appendChild(
          document.createTextNode(" " + finalists.join(", "))
        );
        block.appendChild(finalistsRow);
      }

      const winnerRow = document.createElement("div");
      winnerRow.className = "results-row";
      const winnerLabel = document.createElement("strong");
      winnerLabel.textContent = "Winner:";
      winnerRow.appendChild(winnerLabel);
      winnerRow.appendChild(document.createTextNode(" " + winnerName));
      block.appendChild(winnerRow);

      card.appendChild(block);

      // Track records table
      if (trackLines.length) {
        const records = [];
        const statusSet = new Set(["WIN", "HIGH", "SAFE", "LOW", "BTM", "ELIM"]);

        for (const line of trackLines) {
          if (!line) continue;
          // Example: "Molly Mocktail   WIN HIGH SAFE ELIM"
          const parts = line.split(/\s+/);
          if (!parts.length) continue;

          let firstStatusIdx = -1;
          for (let i = 0; i < parts.length; i++) {
            if (statusSet.has(parts[i])) {
              firstStatusIdx = i;
              break;
            }
          }
          if (firstStatusIdx === -1) continue;

          const name = parts.slice(0, firstStatusIdx).join(" ");
          const rec = parts.slice(firstStatusIdx);
          if (!name) continue;
          records.push({ name, record: rec });
        }

        if (records.length) {
          let maxEpisodes = 0;
          for (const r of records) {
            if (r.record.length > maxEpisodes) maxEpisodes = r.record.length;
          }

          const table = document.createElement("table");
          table.className = "track-record-table";

          const thead = document.createElement("thead");
          const headRow = document.createElement("tr");

          const thName = document.createElement("th");
          thName.textContent = "Contestant";
          headRow.appendChild(thName);

          for (let i = 0; i < maxEpisodes; i++) {
            const th = document.createElement("th");
            th.textContent = String(i + 1);
            headRow.appendChild(th);
          }
          thead.appendChild(headRow);
          table.appendChild(thead);

          const tbody = document.createElement("tbody");
          for (const r of records) {
            const tr = document.createElement("tr");

            const tdName = document.createElement("td");
            tdName.textContent = r.name;
            tdName.className = "track-name";
            tr.appendChild(tdName);

            for (let i = 0; i < maxEpisodes; i++) {
              const status = r.record[i] || "";
              const td = document.createElement("td");
              const cls =
                "status-" + (status ? status.toLowerCase() : "empty");
              td.className = cls;
              td.textContent = status || "";
              tr.appendChild(td);
            }

            tbody.appendChild(tr);
          }

          table.appendChild(tbody);
          card.appendChild(table);
        }
      }
    }

    function getNextLabel(step, index, total) {
      const isLast = index === total - 1;
      if (isLast) return "Restart Season";

      const nextStep = currentSteps[index + 1] || null;

      switch (step.type) {
        case "cast":
          if (nextStep && nextStep.type === "episode_setup") {
            return "Proceed to Episode 1";
          }
          return "Proceed";
        case "episode_setup":
          if (nextStep && nextStep.type === "episode_mini") {
            return "Proceed to Mini-Challenge";
          }
          if (nextStep && nextStep.type === "episode_results") {
            return "Proceed to Judging";
          }
          return "Proceed";
        case "episode_mini":
          if (nextStep && nextStep.type === "episode_results") {
            return "Proceed to Judging";
          }
          return "Proceed";
        case "episode_results":
          return "Next Episode";
        case "final3":
          return "Proceed to Grand Finale";
        default:
          return "Proceed";
      }
    }

    function renderCurrentStep() {
      seasonContainer.innerHTML = "";
      if (!currentSteps.length) {
        seasonContainer.textContent = "No steps available.";
        return;
      }
      const step = currentSteps[currentStepIndex];

      const card = document.createElement("div");
      card.className = "episode-card step-" + step.type;

      const meta = document.createElement("div");
      meta.className = "step-meta";
      meta.textContent =
        "Step " + (currentStepIndex + 1) + " of " + currentSteps.length;
      card.appendChild(meta);

      const h = document.createElement("h3");
      let titleText = "";
      let bodyLines = [];

      switch (step.type) {
        case "cast":
          titleText = "Cast Reveal";
          bodyLines = step.lines;
          break;
        case "episode_setup":
          titleText = `Episode ${step.epNum} â€” ${step.name}`;
          bodyLines = [
            `In Episode ${step.epNum}, the queens face the ${step.name}.`,
            "",
            "Proceed to see the judging and results."
          ];
          break;
        case "episode_mini":
          titleText = `Episode ${step.epNum} â€” Mini-Challenge: ${step.miniName || "Mini-Challenge"}`;
          bodyLines = step.lines;
          break;
        case "episode_results":
          titleText = `Episode ${step.epNum} â€” Judging & Results`;
          bodyLines = step.lines;
          break;
        case "final3":
          titleText = "Final 3 Revealed";
          bodyLines = step.lines;
          break;
        case "finale":
          titleText = "Grand Finale & Track Records";
          bodyLines = step.lines;
          break;
        default:
          titleText = "Season";
          bodyLines = [];
      }

      h.textContent = titleText;
      card.appendChild(h);

      if (bodyLines.length) {
        if (step.type === "episode_setup") {
          const p = document.createElement("p");
          p.textContent = bodyLines.join("\n");
          card.appendChild(p);
        } else if (step.type === "episode_results") {
          renderResultsLines(bodyLines, card);
        } else if (step.type === "episode_mini") {
          renderMiniLines(step, card);
        } else if (step.type === "finale") {
          renderFinaleLines(bodyLines, card);
        } else {
          const pre = document.createElement("pre");
          pre.textContent = bodyLines.join("\n");
          card.appendChild(pre);
        }
      }

      const nav = document.createElement("div");
      nav.className = "step-nav";

      const backBtn = document.createElement("button");
      backBtn.textContent = "Back";
      backBtn.disabled = currentStepIndex === 0;
      backBtn.addEventListener("click", () => {
        if (currentStepIndex > 0) {
          currentStepIndex--;
          renderCurrentStep();
        }
      });

      const nextBtn = document.createElement("button");
      nextBtn.textContent = getNextLabel(
        step,
        currentStepIndex,
        currentSteps.length
      );
      nextBtn.addEventListener("click", () => {
        if (currentStepIndex === currentSteps.length - 1) {
          currentStepIndex = 0;
        } else {
          currentStepIndex++;
        }
        renderCurrentStep();
      });

      nav.appendChild(backBtn);
      nav.appendChild(nextBtn);
      card.appendChild(nav);

      seasonContainer.appendChild(card);
    }

    function renderSeasonFull(log) {
      currentSteps = buildStepsFromLog(log);
      currentStepIndex = 0;
      renderCurrentStep();
    }

    // ---------- Main simulate handler ----------

    simulateBtn.addEventListener("click", () => {
      const queens = JSON.parse(queensInput.value);
      const mode = modeSelect.value;
      const view = viewSelect.value;

      const log = window.simulateSeason(queens, { mode });

      if (view === "summary") {
        renderSeasonSummary(log);
      } else {
        renderSeasonFull(log);
      }
    });

    // Auto-load sample cast
    window.addEventListener("DOMContentLoaded", () => {
      queensInput.value = JSON.stringify(window.QUEENS, null, 2);
    });
  </script>
</body>
</html>
